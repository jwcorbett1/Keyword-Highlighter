<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0">

    <title>Keyword Highlighter</title>

    <style>
/* -------------------------------------------------------------------------- */

body, input {
    font-family: "Courier New", Courier, monospace;
}

/* top-level flexbox */
.container {
    display:        flex;
    flex-direction: column;
    width:          85vw;
    height:         85vh;
    margin:         1.5em auto 0;
    padding:        0;
}

/* typing area */
#editbox {
    flex-grow:   1;     /* fill majority of flexbox */
    white-space: preserve nowrap;
    overflow:    auto;  /* add scrollbars if/when needed */
    border:      0.1em solid black;
    outline:     none;
    margin:      0;
    padding:     0.6em 0.8em;
}

/* container for interface controls */
.toolbar {
    flex-grow: 0;  /* minimize footprint */
    margin:    0;
    padding:   0 0 0.7em;
}

/* invisible control hidden behind toolbar buttons */
#filePicker {
    position: absolute;
    z-index:  -1;
    opacity:  0;
}

#filename {
    width: 40em;
}

/* -------------------------------------------------------------------------- */
/* styling for highlighted elements */

.comment {
    color: green;
}

.literal {
    color: red;
}

.preprocessor {
    color: gray;
}

.macro {
    color: purple;
}

.keyword {
    color: blue;
}

.tagType {
    color: cyan;
}

/* -------------------------------------------------------------------------- */
    </style>
    <script>
// -----------------------------------------------------------------------------
// pre-build complex regular expressions

const preprocessorDirectives = [
    "define",
    "elif",
    "elifdef",
    "elifndef",
    "else",
    "embed",
    "endif",
    "error",
    "if",
    "ifdef",
    "ifndef",
    "include",
    "line",
    "pragma",
    "undef",
    "warning"
];

const keywords = [
    "auto",
    "break",
    "case",
    "const",
    "continue",
    "default",
    "do",
    "else",
    "extern",
    "for",
    "goto",
    "if",
    "register",
    "return",
    "sizeof",
    "static",
    "switch",
    "volatile",
    "while"
];

const dataTypes = [
    "bool",
    "char",
    "double",
    "enum",
    "float",
    "int",
    "long",
    "short",
    "signed",
    "struct",
    "typedef",
    "unsigned",
    "union",
    "void",
    "wchar_t"
];

// <font> tags inserted by some browsers
const oldStylingRegex = /<\/?font[^>]*>|<\/?span[^>]*>/g;
const lineBreakRegex  = /<\/?div>|<br>/;  // doesn't need to be global

const commentRegex = /\/\/.*?<\/?div>|\/\*.*?\*\//g;
const numberRegex  = /-?\.?\d[A-Za-z\d.-]*/g;
const stringRegex  =
    /(?:L|U|u|u8)?(['"]).*?(?<!\\<\/div>|.{6}\\)(?:\1|<div>)/g;

const includeFileRegex  = /#\s*include\s+(&lt;.*?(?:&gt;|<\/?div>))/g;
const defineMacroRegex  = /#\s*define\s+([A-Za-z_]\w*)/g;
const preprocessorRegex = new RegExp(
    "#\\s*(?:" + preprocessorDirectives.join("|") + ")\\b", "g");

const keywordRegex = new RegExp(
    "\\b(?:" + keywords.join("|")  + "|" +
               dataTypes.join("|") + ")\\b", "g");

const localScopeRegex = /\((.*?)\)(?:\s|<\/?div>|<br>)*{/g;
const tagTypeRegex    =
    /\b(?:enum|struct|union)(?:\s|<\/?div>|<br>)+([A-Za-z_]\w*)/g;

// -----------------------------------------------------------------------------
// manage global state

class Scope {
    constructor(start = 0, stop = 0) {
        this.start = start;
        this.stop  = stop;  // first index outside of scope
    }
}

// apply style between these indices
class Style extends Scope {

    constructor(style, start, stop) {
        super(start, stop);
        this.style = style;
    }
}

let   text   = "";
const styles = [];
const scope  = new Scope();

function setScope(start, stop) {
    scope.start = start;
    scope.stop  = stop;
}

function clearScope() {
    scope.start = 0;
    scope.stop  = text.length;
}

// prep for next styling pass
function initializeGlobals(unstyled) {

    text          = unstyled;
    styles.length = 0;
    clearScope();
}

// -----------------------------------------------------------------------------
// apply action to entire regex match

// ACTION - add to styles array, but prevent overlapping
function addStyle(style, start, stop) {

    for (let i = 0; i < styles.length; i++) {
        if (start <  styles[i].stop &&
            stop  >= styles[i].start) {

            return false;  // return value used by tryStyle()
        }
    }

    styles.push(new Style(style, start, stop));
    return true;
}

// ACTION - add, but skip over line breaks
function splitStyle(style, start, stop) {

    // break regex match into lines
    const lines = text
        .substring(start, stop)
        .split(lineBreakRegex)
        .filter(function(s) {
            return s.length > 0; });

    stop = start;
    for (let i = 0; i < lines.length; i++) {

        // find line in original text
        start = text.indexOf(lines[i], stop);
        stop  = start + lines[i].length;

        addStyle(style, start, stop);
    }
}

// ACTION - add, but hide from future regex searches
function styleAndHide(style, start, stop) {

    splitStyle(style, start, stop);

    // replace regex match with spaces
    text = text.substring(0, start) +
           " ".repeat(stop - start) +
           text.substring(stop);
}

// find regex matches and apply given action to each
function styleMatches(regex, action, style) {

    regex.lastIndex = scope.start;

    for (let match = regex.exec(text);
             match !== null;
             match = regex.exec(text)) {

        const start = match.index;
        const stop  = match.index + match[0].length;
        if (stop > scope.stop) {
            break;
        }

        action(style, start, stop);
    }
}

// -----------------------------------------------------------------------------
// apply action only to regex capture group

// ACTION - try to add style to group and report success/failure
function tryStyle(match, style, token = match[1]) {

    // clean up capture group
    token = token.replace(lineBreakRegex, "");

    const start = match.index + match[0].indexOf(token);
    const stop  = start + token.length;

    return addStyle(style, start, stop);
}

// HELPER - search for #undef for given token and return index
function findMacroScope(token, start, style) {

    const regex = new RegExp("#\\s*undef\\s+" + token + "\\b", "g");
    regex.lastIndex = start;

    for (let match = regex.exec(text);
             match !== null;
             match = regex.exec(text)) {

        // check if #undef outside comment/string/etc.
        if (tryStyle(match, style, token)) {
            return match.index;
        }
    }

    return text.length;  // no #undef - goes to end of file
}

// ACTION - test macro, find valid scope, and style within scope
function styleMacro(match, style) {

    // check if #define outside comment/string/etc.
    if (!tryStyle(match, style)) {
        return;
    }

    // limit next search to valid macro scope
    const start = match.index + match[0].length;
    setScope(
        start,
        findMacroScope(match[1], start, style));

    // add style to token within scope
    const regex = RegExp("\\b" + match[1] + "\\b", "g");
    styleMatches(regex, addStyle, style);

    // remove search limit
    clearScope();
}

// find regex capture groups and apply given action to each
function styleGroups(regex, action, style) {

    regex.lastIndex = scope.start;

    for (let match = regex.exec(text);
             match !== null;
             match = regex.exec(text)) {

        const stop = match.index + match[0].length;
        if (stop > scope.stop) {
            break;
        }

        action(match, style);
    }
}

// -----------------------------------------------------------------------------

function findCloser(start, opener, closer) {

    let stop = start;
    do {

        // find first/next closer
        stop = text.indexOf(closer, stop + closer.length);
        if (stop === -1) {
            stop = text.length;
        }

        // find next opener
        start = text.indexOf(opener, start + opener.length);
        if (start === -1) {
            start = text.length;
        }

    // start less than stop only if next opener was nested
    // if nested, current closer matches with wrong opener
    } while (start < stop);  // using <= can cause infinite loop

    // return index of closer which matches with original opener
    return stop;
}

function findIdentifiers(regex, start, identifiers) {

    // should potential identifier be added or ignored?
    let addMatch = true;

    regex.lastIndex = start;
    for (let match = regex.exec(text);
             match !== null;
             match = regex.exec(text)) {

        // match against 2nd capture group
        switch (match[2]) {

            case "{":
            case "[":
            case "=":
            case ",":

            case ";":
            case ")":
        }
    }
}

function styleLocalScopes() {

    // start at beginning of file
    localScopeRegex.lastIndex = 0;

    for (let match = localScopeRegex.exec(text);
             match !== null;
             match = localScopeRegex.exec(text)) {

        const start = localScopeRegex.lastIndex - 1;
        const stop  = findCloser(start, "{", "}");

        localScopeRegex.lastIndex = stop + 1;
    }
}

// -----------------------------------------------------------------------------
// determine and apply styling to typing area

function applyStyles(unstyled) {

    if (styles.length === 0) {
        return unstyled;
    }

    // easier to apply styles in order
    styles.sort(function(a, b) {
        return a.start - b.start; });

    // create short name for String.substring() calls
    const getPart = unstyled.substring.bind(unstyled);

    // get initial region with no styling
    let html = getPart(0, styles[0].start);

    for (let i = 0; i < styles.length; i++) {

        // add styling to this region
        html += "<span class='" + styles[i].style + "'>" +
                getPart(styles[i].start, styles[i].stop) +
                "</span>";

        // add region between here and next styling
        if (i + 1 < styles.length) {
            html += getPart(styles[i].stop, styles[i + 1].start);
        } else {
            html += getPart(styles[i].stop);  // remainder of text
        }
    }

    return html;
}

// try to keep caret in same spot
// not 100% effective, but good enough for now
function maintainCaret(editbox, html) {

    // confirm caret is active
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0) {
        editbox.innerHTML = html;
        return;
    }

    // get index to current location
    const range = selection.getRangeAt(0).cloneRange();
    range.setStart(editbox, 0);
    let caret = range.toString().length;

    editbox.innerHTML = html;

    // step through newly created DOM tree to same index value
    const tree = document.createTreeWalker(editbox, NodeFilter.SHOW_TEXT);
    while (tree.nextNode() && caret > tree.currentNode.length) {
        caret -= tree.currentNode.length;
    }
    caret = Math.min(caret, tree.currentNode.length);

    // move caret to same index value (roughly)
    range.setStart(tree.currentNode, caret);
    range.collapse(true);
    selection.removeAllRanges();
    selection.addRange(range);
}

function styleEditbox() {

    // get text, remove old styling, and prep for next styling pass
    const editbox  = document.getElementById("editbox");
    const unstyled = editbox.innerHTML.replace(oldStylingRegex, "");
    initializeGlobals(unstyled);

    styleMatches(commentRegex, styleAndHide, "comment");

    styleMatches(stringRegex,     splitStyle, "literal");
    styleGroups(includeFileRegex, tryStyle,   "literal");
    styleMatches(numberRegex,     addStyle,   "literal");

    styleMatches(preprocessorRegex, addStyle,   "preprocessor");
    styleGroups(defineMacroRegex,   styleMacro, "macro");

    styleMatches(keywordRegex, addStyle, "keyword");
    styleGroups(tagTypeRegex,  tryStyle, "tagType");

    // replace old content with newly styled content
    maintainCaret(editbox, applyStyles(unstyled));
}

// -----------------------------------------------------------------------------

let hasChanges = false;
let stylingTimer;

// -------------------------------------

// after no typing for 2 seconds, update styling
function debounceStyling() {

    hasChanges = true;  // function triggered by user input

    clearTimeout(stylingTimer);
    stylingTimer = setTimeout(styleEditbox, 2000);
}

// helper function
function dropChanges() {

    return !hasChanges ||
           confirm("You will lose any unsaved changes.");
}

function clearEditbox() {

    if (!dropChanges()) {
        return;
    }

    // reset to default values
    document.getElementById("editbox").innerHTML = "";
    document.getElementById("filename").value    = "temp.txt";
    hasChanges                                   = false;
}

// -------------------------------------

function selectFile() {

    if (!dropChanges()) {
        return;
    }

    document.getElementById("filePicker").click();
}

// convert plain text to HTML
function convertFile(contents) {

    // clean file contents and split into lines
    const lines = contents
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .split(/\r*\n|\r/);  // split on any type of line break

    if (lines.length < 2) {
        return lines[0];  // return one and only line
    }

    // wrap each line in <div> tags
    let html = "";
    for (let i = 0; i < lines.length; i++) {

        if (lines[i].length === 0) {
            lines[i] = "<br>";  // required for empty lines
        }

        html += "<div>" + lines[i] + "</div>";
    }

    return html;
}

// load file contents into typing area
function openFile() {

    // check if user cancelled file picker
    if (this.files.length === 0) {
        return;
    }

    // set visible file name
    let filename = this.files[0].name;
    if (filename.indexOf(".") === -1) {
        filename += ".";
    }
    document.getElementById("filename").value = filename;

    // set up file reader object
    const reader = new FileReader();
    reader.addEventListener("load", function() {

        document
            .getElementById("editbox")
            .innerHTML = convertFile(reader.result);

        styleEditbox();
        hasChanges = false;  // clear dirty flag
    });

    reader.readAsText(this.files[0]);
    this.value = "";  // clear file picker for reuse
}

// -------------------------------------

function downloadFile() {

    let name = document.getElementById("filename").value;
    let type = "text/plain";

    // use default extension?
    if (name.indexOf(".") === -1) {
        name += ".txt";
    }

    // use no extension?
    else if (name.at(-1) === ".") {
        name = name.substring(0, name.length - 1);
        type = "application/octet-stream";  // prevent brower's "help"
    }

    // convert HTML to plain text
    let contents = document
        .getElementById("editbox")
        .innerHTML
        .replace(oldStylingRegex, "")
        .replace(/<div>/g,        "\n")
        .replace(/<\/div>|<br>/g, "")
        .replace(/&lt;/g,         "<")
        .replace(/&gt;/g,         ">");

    // first line may or may not have been inside <div> tag
    if (contents[0] === "\n") {
        contents = contents.substring(1);  // remove extra line
    }

    // create temp link for file download
    const file    = new Blob([contents], { type: type });
    const url     = URL.createObjectURL(file);
    const link    = document.createElement("a");
    link.href     = url;
    link.download = name;  // set file name

    // click link for user, then clean up
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);

    hasChanges = false;  // clear dirty flag
}

// -------------------------------------

// attach event listeners and initialize editbox
function initializePage() {

    document
        .getElementById("editbox")
        .addEventListener("input", debounceStyling);

    document
        .getElementById("filePicker")
        .addEventListener("change", openFile);

    clearEditbox();
}

// -----------------------------------------------------------------------------
    </script>

</head>
<body onload="initializePage()">
<div class="container">

    <div class="toolbar">

        <input type="button"
               value="New File"
               onclick="clearEditbox()">

        <!-- triggers file picker control (see below) -->
        <input type="button"
               value="Open File"
               onclick="selectFile()">

        <input type="button"
               value="Save to Downloads"
               onclick="downloadFile()">

        <label for="filename">Current File:</label>
        <input type="text"
               id="filename">

        <!-- invisible control hidden behind toolbar buttons -->
        <input type="file"
               id="filePicker"
               accept="text/plain">

    </div><!-- end of toolbar -->

    <div id="editbox"
         contenteditable="true"
         spellcheck="false"></div>

</div><!-- end of container -->
</body>
</html>
