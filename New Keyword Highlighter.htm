<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0">

    <title>Keyword Highlighter</title>

    <style>
/* -------------------------------------------------------------------------- */

body, input {
    font-family: "Courier New", Courier, monospace;
}

/* top-level flexbox */
.container {
    display:        flex;
    flex-direction: column;
    width:          85vw;
    height:         85vh;
    margin:         1.5em auto 0;
    padding:        0;
}

/* typing area */
#editbox {
    flex-grow:   1;     /* fill majority of flexbox */
    white-space: preserve nowrap;
    overflow:    auto;  /* add scrollbars if/when needed */
    border:      0.1em solid black;
    outline:     none;
    margin:      0;
    padding:     0.6em 0.8em;
}

/* container for interface controls */
.toolbar {
    flex-grow: 0;  /* minimize footprint */
    margin:    0;
    padding:   0 0 0.7em;
}

/* invisible and hidden behind toolbar buttons */
#filePicker {
    position: absolute;
    z-index:  -1;
    opacity:  0;
}

#filename {
    width:   40em;
    outline: none;
}

/* -------------------------------------------------------------------------- */
/* styling for highlighted elements */

.comment {
    color: green;
}

.literal {
    color: red;
}

.preprocessor {
    color: gray;
}

.macro, .constant {
    color: purple;
}

.keyword {
    color: blue;
}

.tagType, .typedef {
    color: cyan;
}

.function {
    color: orange;
}

.parameter {
    color: pink;
}

.variable {
    color: coral;
}

/* -------------------------------------------------------------------------- */
    </style>
    <script>
// -----------------------------------------------------------------------------
// building complex regular expressions

const preprocessorDirectives = [
    "define",
    "elif",
    "elifdef",
    "elifndef",
    "else",
    "embed",
    "endif",
    "error",
    "if",
    "ifdef",
    "ifndef",
    "include",
    "line",
    "pragma",
    "undef",
    "warning"
];

const keywords = [
    "auto",
    "break",
    "case",
    "const",
    "continue",
    "default",
    "do",
    "else",
    "extern",
    "for",
    "goto",
    "if",
    "register",
    "return",
    "sizeof",
    "static",
    "switch",
    "volatile",
    "while"
];

const dataTypes = [
    "bool",
    "char",
    "double",
    "enum",
    "float",
    "int",
    "long",
    "short",
    "signed",
    "struct",
    "typedef",
    "unsigned",
    "union",
    "void",
    "wchar_t"
];

// <font> tags inserted by some browsers
const oldStylingRegex = /<\/?font[^>]*>|<\/?span[^>]*>/g;
const lineBreakRegex  = /<\/?div>|<br>/;  // doesn't need to be global

const commentRegex = /\/\/.*?<\/?div>|\/\*.*?\*\//g;
const numberRegex  = /(?<![A-Za-z_])\-?\.?\d[A-Za-z\d\-\.]*/g;
const stringRegex  =
    /(?:L|U|u|u8)?(['"]).*?(?<!\\<\/div>|.{6}\\)(?:\1|<div>)/g;

const includeFileRegex  = /#\s*include\s+(&lt;.*?(?:&gt;|<\/?div>))/g;
const defineMacroRegex  = /#\s*define\s+([A-Za-z_]\w*)/g;
const preprocessorRegex = new RegExp(
    "#\\s*(?:" + preprocessorDirectives.join("|") + ")\\b", "g");

const enumerationRegex = /\benum\b[^;]*;/g;
const tagTypeRegex     =
    /\b(?:enum|struct|union)(?:\s|<\/?div>|<br>)+([A-Za-z_]\w*)/g;

const functionNameRegex  =
    /\b([A-Za-z_]\w*)(?:\s|<\/?div>|<br>)*\(/g;
const variableNameRegex  =
    /\b([A-Za-z_]\w*)?(?:\s|<\/?div>|<br>)*([\{\[=,;])/g;
const parameterNameRegex =
    /\b([A-Za-z_]\w*)?(?:\s|<\/?div>|<br>)*([\[,\)])/g;
const enumConstantRegex  =
    /\b([A-Za-z_]\w*)?(?:\s|<\/?div>|<br>)*([=,\}])/g;

const localScopeRegex = new RegExp(
    "\\b([A-Za-z_]\\w*)(?:\\s|<\\/?div>|<br>)*" +
         "\\([^\\)]*\\)(?:\\s|<\\/?div>|<br>)*\\{", "g");

// -----------------------------------------------------------------------------
// manage global state

class Scope {
    constructor(start = 0, stop = 0) {
        this.start = start;
        this.stop  = stop;  // first index outside of scope
    }
}

// apply style between these indices
class Style extends Scope {

    constructor(style, start, stop) {
        super(start, stop);
        this.style = style;
    }
}

let   text   = "";
const styles = [];
const scope  = new Scope();

function setScope(start, stop) {
    scope.start = start;
    scope.stop  = stop;
}

function clearScope() {
    scope.start = 0;
    scope.stop  = text.length;
}

// prep for next styling pass
function initializeGlobals(unstyled) {

    text          = unstyled;
    styles.length = 0;
    clearScope();
}

// -----------------------------------------------------------------------------
// apply action to entire regex match

// ACTION - add to styles array, but prevent overlapping
function addStyle(style, start, stop) {

    for (let i = 0; i < styles.length; i++) {
        if (start <  styles[i].stop &&
            stop  >= styles[i].start) {

            return false;  // return value used by tryStyle()
        }
    }

    styles.push(new Style(style, start, stop));
    return true;
}

// ACTION - add, but skip over line breaks
function splitStyle(style, start, stop) {

    // break regex match into lines
    const lines = text
        .substring(start, stop)
        .split(lineBreakRegex)
        .filter(function(s) {
            return s.length > 0; });

    stop = start;
    for (let i = 0; i < lines.length; i++) {

        // find line in original text
        start = text.indexOf(lines[i], stop);
        stop  = start + lines[i].length;

        addStyle(style, start, stop);
    }
}

// ACTION - add, but hide from future regex searches
function styleAndHide(style, start, stop) {

    splitStyle(style, start, stop);

    // replace regex match with spaces
    text = text.substring(0, start) +
           " ".repeat(stop - start) +
           text.substring(stop);
}

// find regex matches and apply given action to each
function styleMatches(regex, action, style) {

    regex.lastIndex = scope.start;

    for (let match = regex.exec(text);
             match !== null;
             match = regex.exec(text)) {

        const start = match.index;
        const stop  = match.index + match[0].length;
        if (stop > scope.stop) {
            break;
        }

        action(style, start, stop);
    }
}

// build regex, find token(s) and apply given style to each
function quickStyle(tokens, style) {

    if (tokens) {
        const regex = new RegExp("\\b(?:" + tokens + ")\\b", "g");
        styleMatches(regex, addStyle, style);
    }
}

// -----------------------------------------------------------------------------
// apply action only to regex capture group

// ACTION - try to add style to group and report success/failure
function tryStyle(match, style, token = match[1]) {

    // clean up capture group
    token = token.replace(lineBreakRegex, "");

    const start = match.index + match[0].indexOf(token);
    const stop  = start + token.length;

    return addStyle(style, start, stop);
}

// HELPER - search for #undef for given token and return index
function findMacroScope(token, start, style) {

    const regex = new RegExp("#\\s*undef\\s+" + token + "\\b", "g");
    regex.lastIndex = start;

    for (let match = regex.exec(text);
             match !== null;
             match = regex.exec(text)) {

        // check if #undef outside comment/string/etc.
        if (tryStyle(match, style, token)) {
            return match.index;
        }
    }

    return text.length;  // no #undef - goes to end of file
}

// ACTION - test macro, find valid scope, and style within scope
function styleMacro(match, style) {

    // check if #define outside comment/string/etc.
    if (!tryStyle(match, style)) {
        return;
    }

    // limit next search to valid macro scope
    const start = match.index + match[0].length;
    setScope(
        start,
        findMacroScope(match[1], start, style));

    // add style to tokens within scope
    quickStyle(match[1], style);
    clearScope();  // remove search limit
}

function styleFunction(match, style) {

    // check if function name outside comment/string/etc.
    if (!tryStyle(match, style)) {
        return;
    }

    // add style to all valid tokens
    quickStyle(match[1], style);
}

// find regex capture groups and apply given action to each
function styleGroups(regex, action, style) {

    regex.lastIndex = scope.start;

    for (let match = regex.exec(text);
             match !== null;
             match = regex.exec(text)) {

        const stop = match.index + match[0].length;
        if (stop > scope.stop) {
            break;
        }

        action(match, style);
    }
}

// -----------------------------------------------------------------------------

// find brace/bracket which matches brace/bracket at starting index
function findCloser(start, opener, closer) {

    let stop = start;
    do {

        // find first/next closer
        stop = text.indexOf(closer, stop + closer.length);
        if (stop === -1) {
            stop = text.length;
        }

        // find next opener
        start = text.indexOf(opener, start + opener.length);
        if (start === -1) {
            start = text.length;
        }

    // if start less than stop, next opener was nested
    // if nested, current closer doesn't match original opener
    } while (start < stop);  // using <= can cause infinite loop

    // return index of closer matching original opener
    return stop;
}

// extract valid identifiers from current segment of text
// works for variables, function parameters, and enum constants
function findIdentifiers(regex, identifiers) {

    // helper function
    const addMatch = function(m) {
        if (m) { identifiers.push(m); } };

    // should identifier be added to list or ignored?
    let validMatch = true;
    let start;  // temp variable

    regex.lastIndex = scope.start;
    for (let match = regex.exec(text);
             match !== null;
             match = regex.exec(text)) {

        const stop = match.index + match[0].length;
        if (stop > scope.stop) {
            break;
        }

        // regex parameter determines which cases are actually used
        switch (match[2]) {

            // skip over anything inside braces
            case "{":
                start           = regex.lastIndex - 1;
                regex.lastIndex = findCloser(start, "{", "}") + 1;
                break;

            // if first valid match, add identifier before brackets
            // then skip over anything inside brackets
            case "[":
                if (validMatch) {
                    addMatch(match[1]);
                    validMatch = false;
                }
                start           = regex.lastIndex - 1;
                regex.lastIndex = findCloser(start, "[", "]") + 1;
                break;

            // if first valid match, add identifier before equals sign
            case "=":
                if (validMatch) {
                    addMatch(match[1]);
                    validMatch = false;
                }
                break;

            // if first valid match, add identifier before comma
            // reset valid match flag either way
            case ",":
                if (validMatch) {
                    addMatch(match[1]);
                }
                validMatch = true;
                break;

            // if first valid match, add identifier before delimiter
            case ";":  // ends variable declaration
            case ")":  // ends parameter list
            case "}":  // ends enum constants list
                if (validMatch) {
                    addMatch(match[1]);
                }
                return;  // delimiter found
        }
    }
}

function styleIdentifiers(stop, match, regex, style) {

    // confirm still within valid scope
    const matchEnd = match.index + match[0].length;
    if (matchEnd > stop) {
        return null;
    }

    // extract identifiers
    const identifiers = [];
    setScope(match.index, matchEnd);
    findIdentifiers(regex, identifiers);

    // style identifiers
    scope.stop = stop;
    quickStyle(identifiers.join("|"), style);
    clearScope();

    return identifiers;  // return for typedef handling
}

function styleEnumerations(start, stop, style) {

    enumerationRegex.lastIndex = start;

    for (let match = enumerationRegex.exec(text);
             match !== null;
             match = enumerationRegex.exec(text)) {

        if (!styleIdentifiers(stop, match, enumConstantRegex, style)) {
            break;
        }
    }
}

// helper function - manage data types regex for styleVariables()
function createTypesRegex(start, types = null, previous = null) {

    const begin = "\\b(?:";
    const end   = ")\\b[^;]*;";

    let regex;
    if (!previous) {
        regex = new RegExp(begin + dataTypes.join("|") + end, "g");
        regex.lastIndex = start;  // initialize last index
    }

    else {
        // combine previously found types with newly located typedefs
        const combined = previous
            .source
            .replace(begin, "")
            .replace(end,   "") + "|" + types.join("|");

        regex           = new RegExp(begin + combined + end, "g");
        regex.lastIndex = previous.lastIndex;  // carry over last index
    }

    return regex;
}

function styleVariables(start, stop, variables, typedefs) {

    let regex = createTypesRegex(start);

    for (let match = regex.exec(text);
             match !== null;
             match = regex.exec(text)) {

        let style = variables;
        if (match[0].indexOf("typedef") !== -1) {
            style = typedefs;  // actually declaring typdefs instead
        }

        const types = styleIdentifiers(
            stop, match, variableNameRegex, style);

        // confirm still within valid scope
        if (!types) {
            break;
        }

        // add newly located typedefs to regex
        if (style === typedefs) {
            regex = createTypesRegex(0, types, regex);
        }
    }
}

function styleLocalScopes(
    functions, parameters, variables, typedefs, constants) {

    // start at beginning of text
    localScopeRegex.lastIndex = 0;

    const functionNames = [];
    for (let match = localScopeRegex.exec(text);
             match !== null;
             match = localScopeRegex.exec(text)) {

        // confirm valid function
        if (!tryStyle(match, functions)) {
            continue;
        }
        functionNames.push(match[1]);

        // find indices for function body
        const start = localScopeRegex.lastIndex - 1;
        const stop  = findCloser(start, "{", "}");

        // style parameters, and local variables and typedefs
        styleIdentifiers(stop, match, parameterNameRegex, parameters);
        styleEnumerations(start, stop, constants);
        styleVariables(start, stop, variables, typedefs);

        // resume search at end of this function
        localScopeRegex.lastIndex = stop + 1;
    }

    return functionNames;
}

// -----------------------------------------------------------------------------
// determine and apply styling to typing area

function applyStyles(unstyled) {

    if (styles.length === 0) {
        return unstyled;
    }

    // easier to apply styles in order
    styles.sort(function(a, b) {
        return a.start - b.start; });

    // create short name for String.substring() calls
    const getPart = unstyled.substring.bind(unstyled);

    // get initial region with no styling
    let html = getPart(0, styles[0].start);

    for (let i = 0; i < styles.length; i++) {

        // add styling to this region
        html += "<span class='" + styles[i].style + "'>" +
                getPart(styles[i].start, styles[i].stop) +
                "</span>";

        // add region between here and next styling
        if (i + 1 < styles.length) {
            html += getPart(styles[i].stop, styles[i + 1].start);
        } else {
            html += getPart(styles[i].stop);  // remainder of text
        }
    }

    return html;
}

function convertToPosition(editbox, range) {

    let node     = range.endContainer;
    let position = range.endOffset;
    let rawText  = false;

    if (node === editbox || !editbox.contains(node)) {
        return 0;
    }

    while (node.parentNode !== editbox) {

        while (node.previousSibling !== null) {
            node      = node.previousSibling;
            position += node.textContent.length;
        }

        node = node.parentNode;
    }

    for (let child = editbox.firstChild;
             child !== node;
             child = child.nextSibling) {

        position += child.textContent.length;
        switch (child.nodeName) {

            case "DIV":
                position++;
                break;

            case "#text":
                rawText = true;
                break;
        }
    }

    if (rawText) {
        position++;
    }

    return position;
}

function collapsedRange(node, offset) {

    const range = document.createRange();
    range.setEnd(node, offset);
    range.collapse();

    return range;
}

function convertToRange(editbox, position) {

    let node = editbox.firstChild;
    if (node === null) {
        return collapsedRange(editbox, 0);
    }

    while (node !== null && position > node.textContent.length) {

        position -= node.textContent.length;
        if (node.nodeName === "DIV") {
            position--;
        }

        node = node.nextSibling;
    }

    while (node !== null) {

        if (position >= node.textContent.length) {
            position -= node.textContent.length;
            node      = node.nextSibling;
        }

        else if (node.firstChild !== null) {
            node = node.firstChild;
        }

        else break;
    }

    if (node === null) {

        node = editbox.lastChild;
        while (node.lastChild !== null) {
            node = node.lastChild;
        }

        position = node.textContent.length;
    }

    return collapsedRange(node, position);
}

// try to keep caret in same spot
// not 100% effective, but good enough for now
function maintainCaret(editbox, html) {

    // confirm caret is active
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0) {
        editbox.innerHTML = html;
        return;
    }

/*
    // get index to current location
    const range = selection.getRangeAt(0).cloneRange();
    range.setStart(editbox, 0);
    let caret = range.toString().length;
*/

    const position = convertToPosition(editbox, selection.getRangeAt(0));
    alert("Position: " + position);
    editbox.innerHTML = html;

/*
    // step through newly created DOM tree to same index value
    const tree = document.createTreeWalker(editbox, NodeFilter.SHOW_TEXT);
    while (tree.nextNode() && caret > tree.currentNode.length) {
        caret -= tree.currentNode.length;
    }
    caret = Math.min(caret, tree.currentNode.length);

    // move caret to same index value (roughly)
    range.setStart(tree.currentNode, caret);
    range.collapse(true);
*/

    const range = convertToRange(editbox, position);
    selection.removeAllRanges();
    selection.addRange(range);
}

function styleEditbox() {

    // get text, remove old styling, and prep for next styling pass
    const editbox  = document.getElementById("editbox");
    const unstyled = editbox.innerHTML.replace(oldStylingRegex, "");
    initializeGlobals(unstyled);

    styleMatches(commentRegex, styleAndHide, "comment");

    styleMatches(stringRegex,     splitStyle, "literal");
    styleGroups(includeFileRegex, tryStyle,   "literal");
    styleMatches(numberRegex,     addStyle,   "literal");

    styleMatches(preprocessorRegex, addStyle,   "preprocessor");
    styleGroups(defineMacroRegex,   styleMacro, "macro");

    quickStyle(keywords.concat(dataTypes).join("|"), "keyword");
    styleGroups(tagTypeRegex, tryStyle, "tagType");

    // style all local scopes first
    const functionNames = styleLocalScopes(
        "function", "parameter", "variable", "typedef", "constant");

    // style global scope last
    styleEnumerations(0, text.length, "constant");
    styleVariables(   0, text.length, "variable", "typedef");
    quickStyle(functionNames.join("|"), "function");
    styleGroups(functionNameRegex, styleFunction, "function");

    // replace old content with newly styled content
    maintainCaret(editbox, applyStyles(unstyled));
}

// -----------------------------------------------------------------------------

let hasChanges = false;
let stylingTimer;

// -------------------------------------

// after no typing for 2 seconds, update styling
function debounceStyling() {

    hasChanges = true;  // function triggered by user input

    clearTimeout(stylingTimer);
    stylingTimer = setTimeout(styleEditbox, 2000);
}

// helper function
function dropChanges() {

    return !hasChanges ||
           confirm("You will lose any unsaved changes.");
}

function clearEditbox() {

    if (!dropChanges()) {
        return;
    }

    // reset to default values
    document.getElementById("editbox").innerHTML = "";
    document.getElementById("filename").value    = "temp.txt";
    hasChanges                                   = false;
}

// -------------------------------------

function selectFile() {

    if (!dropChanges()) {
        return;
    }

    document.getElementById("filePicker").click();
}

// convert plain text to HTML
function convertFile(contents) {

    // clean file contents and split into lines
    const lines = contents
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .split(/\r*\n|\r/);  // split on any type of line break

    if (lines.length < 2) {
        return lines[0];  // return one and only line
    }

    // wrap each line in <div> tags
    let html = "";
    for (let i = 0; i < lines.length; i++) {

        if (lines[i].length === 0) {
            lines[i] = "<br>";  // required for empty lines
        }

        html += "<div>" + lines[i] + "</div>";
    }

    return html;
}

// load file contents into typing area
function openFile() {

    // check if user cancelled file picker
    if (this.files.length === 0) {
        return;
    }

    // set visible file name
    let filename = this.files[0].name;
    if (filename.indexOf(".") === -1) {
        filename += ".";
    }
    document.getElementById("filename").value = filename;

    // set up file reader object
    const reader = new FileReader();
    reader.addEventListener("load", function() {

        document
            .getElementById("editbox")
            .innerHTML = convertFile(reader.result);

        styleEditbox();
        hasChanges = false;  // clear dirty flag
    });

    reader.readAsText(this.files[0]);
    this.value = "";  // clear file picker for reuse
}

// -------------------------------------

function downloadFile() {

    let name = document.getElementById("filename").value;
    let type = "text/plain";

    // use default extension?
    if (name.indexOf(".") === -1) {
        name += ".txt";
    }

    // use no extension?
    else if (name.at(-1) === ".") {
        name = name.substring(0, name.length - 1);
        type = "application/octet-stream";  // prevent brower's "help"
    }

    // convert HTML to plain text
    let contents = document
        .getElementById("editbox")
        .innerHTML
        .replace(oldStylingRegex, "")
        .replace(/<div>/g,        "\n")
        .replace(/<\/div>|<br>/g, "")
        .replace(/&lt;/g,         "<")
        .replace(/&gt;/g,         ">");

    // first line may or may not have been inside <div> tag
    if (contents[0] === "\n") {
        contents = contents.substring(1);  // remove extra line
    }

    // create temp link for file download
    const file    = new Blob([contents], { type: type });
    const url     = URL.createObjectURL(file);
    const link    = document.createElement("a");
    link.href     = url;
    link.download = name;  // set file name

    // click link for user, then clean up
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);

    hasChanges = false;  // clear dirty flag
}

// -------------------------------------

// attach event listeners and initialize editbox
function initializePage() {

    document
        .getElementById("editbox")
        .addEventListener("input", debounceStyling);

    document
        .getElementById("filePicker")
        .addEventListener("change", openFile);

    clearEditbox();
}

// -----------------------------------------------------------------------------
    </script>

</head>
<body onload="initializePage()">
<div class="container">

    <div class="toolbar">

        <input type="button"
               value="New File"
               onclick="clearEditbox()">

        <!-- triggers file picker control (see below) -->
        <input type="button"
               value="Open File"
               onclick="selectFile()">

        <input type="button"
               value="Save to Downloads"
               onclick="downloadFile()">

        <label for="filename">Current File:</label>
        <input type="text"
               id="filename">

        <!-- invisible and hidden behind toolbar buttons -->
        <input type="file"
               id="filePicker"
               accept="text/plain">

    </div><!-- end of toolbar -->

    <div id="editbox"
         contenteditable="true"
         spellcheck="false"></div>

</div><!-- end of container -->
</body>
</html>



