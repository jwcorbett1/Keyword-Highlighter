<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0">

    <title>Keyword Highlighter</title>

    <style>
/* -------------------------------------------------------------------------- */

/* font settings for all text and controls */
body, input {
    font-family: "Courier New", Courier, monospace;
}

/* top-level flexbox */
.viewPort {
    display:        flex;
    flex-direction: column;
    width:          85vw;
    height:         85vh;
    margin:         1.5em auto 0;
    padding:        0;
}

#editBox {
    flex-grow:   1;     /* fill majority of viewport */
    white-space: preserve nowrap;
    overflow:    auto;  /* add scrollbars if/when needed */
    border:      0.1em solid black;
    outline:     none;
    margin:      0;
    padding:     0.6em 0.8em;
}

.toolBar {
    flex-grow: 0;  /* minimize footprint */
    margin:    0;
    padding:   0 0 0.7em;
}

/* invisible and hidden behind other controls */
#filePicker {
    position: absolute;
    z-index:  -1;
    opacity:  0;
}

#fileName {
    width: 40em;
}

/* -------------------------------------------------------------------------- */
/* colors to use for each type of token */

.comment {
    color: green;
}

.literal {
    color: red;
}

.keyword {
    color: blue;
}

.preprocessor {
    color: gray;
}

.macro {
    color: purple;
}

.function {
    color: orange;
}

.variable {
    color: magenta;
}

.userDefined {
    color: cyan;
}

/* -------------------------------------------------------------------------- */
    </style>
    <script>
// -----------------------------------------------------------------------------
// keywords divided up by handling needs

// #define handled separately
const preprocessor = [
    "#elif",
    "#else",
    "#endif",
    "#error",
    "#if",
    "#ifdef",
    "#ifndef",
    "#include",
    "#pragma",
    "#undef"
];

// typedef handled separately
const keyword = [
    "auto",
    "break",
    "case",
    "const",
    "continue",
    "default",
    "do",
    "else",
    "extern",
    "for",
    "goto",
    "if",
    "register",
    "return",
    "sizeof",
    "static",
    "switch",
    "volatile",
    "while"
];

const dataType = [
    "bool",
    "char",
    "double",
    "float",
    "int",
    "long",
    "short",
    "signed",
    "unsigned",
    "void",
    "wchar_t"
];

const composite = [
    "enum",
    "struct",
    "union"
];

// -----------------------------------------------------------------------------

// base-level data structure
class Styling {

    constructor(style, start, stop) {

        this.style = style;
        this.start = start;  // first index to apply style
        this.stop  = stop;   // first index to stop applying style
    }
}

// return index of Styling data immediately before a position
function findLastIndexBefore(styles, index) {

    if (styles.length === 0 || styles[0].stop > index) {
        return -1;
    }

    let i = 0;
    while (i + 1 < styles.length && styles[i + 1].stop <= index) {
        i++;
    }

    return i;
}

// embed Styling data into text and return result
function buildStyledHTML(text, styles) {

    // sort array by start index
    styles.sort(function(a, b) { return a.start - b.start; });

    let html = text.substring(0, styles[0].start);  // before any styling
    for (let i = 0; i < styles.length; i++) {

        html += "<span class='" + styles[i].style + "'>" +
                text.substring(styles[i].start, styles[i].stop) +
                "</span>";

        if (i + 1 < styles.length) {
            html += text.substring(styles[i].stop, styles[i + 1].start);
        } else {
            html += text.substring(styles[i].stop);  // until end of text
        }
    }

    return html;
}

// -----------------------------------------------------------------------------

// builder to apply styling step-by-step
class StyleBuilder {

    constructor(html) {

        this.original = html;  // copy for creating styled HTML
        this.edited   = html;  // copy without "hidden" text
        this.styling  = [];    // holds Styling objects

        // range to use for regex searches
        this.startAt  = 0;            // first index to start searching
        this.stopAt   = html.length;  // first index to stop searching
    }

    // ---------------------------------

    // in future, search only part of edited string
    setScope(startAt, stopAt) {

        this.startAt = startAt;
        this.stopAt  = stopAt;
    }

    // in future, search entire edited string
    clearScope() {

        this.startAt = 0;
        this.stopAt  = this.original.length;
    }

    // ---------------------------------

    addStyling(style, start, stop) {

        // check if start/stop overlaps existing styling
        for (let i = 0; i < this.styling.length; i++) {

            if (start < this.styling[i].stop &&
                this.styling[i].start < stop) {

                return;  // overlap not allowed!
            }
        }

        this.styling.push(new Styling(style, start, stop));
    }

    // remove all Styling objects with this style
    removeStyling(style) {

        this.styling = this.styling
            .filter(function(s) { return s.style !== style; });
    }

    // ---------------------------------

    // add styling, but skip over regex matches
    splitStyling(style, start, stop, regex) {

        const segments = this.edited
            .substring(start, stop)
            .split(regex)
            .filter(function(s) { return s.length > 0; });

        stop = start;  // no previous match
        for (let i = 0; i < segments.length; i++) {

            // find match after end of previous match
            start = this.edited.indexOf(segments[i], stop);
            stop  = start + segments[i].length;

            this.addStyling(style, start, stop);
        }
    }

    // replace text with same number of filler characters
    hideRange(start, stop, begin = "", end = "") {

        this.edited =
            this.edited.substring(0, start) +
            begin +  // optional - marks beginning of deletion
            " ".repeat((stop - start) - (begin.length + end.length)) +
            end +    // optional - marks end of deletion
            this.edited.substring(stop);
    }

    // add styling to and/or hide regex matches
    // beginMark = "" and endMark = "" will fully hide matches
    // only searches between this.startAt and this.stopAt
    updateMatchedText(regex, style = "",
        splitRegex = null, beginMark = null, endMark = null) {

        regex.lastIndex = this.startAt;

        for (let match = regex.exec(this.edited);
                 match !== null;
                 match = regex.exec(this.edited)) {

            const start = match.index;
            const stop  = start + match[0].length;

            if (stop > this.stopAt) {
                break;
            }

            if (style !== "") {
                if (splitRegex === null) {
                    this.addStyling(style, start, stop);
                } else {
                    this.splitStyling(style, start, stop, splitRegex);
                }
            }

            if (beginMark !== null) {
                this.hideRange(start, stop, beginMark, endMark);
            }
        }
    }

    // ---------------------------------

    // add styling to each capture group at same time
    // styles = ["", "example"] only styles 2nd capture group
    addCaptureGroups(match, styles) {

        for (let i = 0;
                 i < styles.length && i + 1 < match.length;
                 i++) {

            if (styles[i] !== "") {

                const start = match.index +
                              match[0].indexOf(match[i + 1]);

                this.addStyling(
                    styles[i],
                    start,
                    start + match[i + 1].length);
            }
        }
    }

    // builds list of unique capture group results with each call
    // groups = [null, [] ] only records 2nd capture group results
    addUniqueCaptures(match, groups) {

        for (let i = 0;
                 i < groups.length && i + 1 < match.length;
                 i++) {

            if (groups[i] !== null && !groups[i].includes(match[i + 1])) {

                groups[i].push(match[i + 1]);
            }
        }
    }

    // add styling to and/or build list of capture group matches
    // only searches between this.startAt and this.stopAt
    findCaptureGroups(regex, styles = null, groups = null) {

        regex.lastIndex = this.startAt;

        for (let match = regex.exec(this.edited);
                 match !== null &&
                 match.index + match[0].length <= this.stopAt;
                 match = regex.exec(this.edited)) {

            if (styles !== null) {
                this.addCaptureGroups(match, styles);
            }

            if (groups !== null) {
                this.addUniqueCaptures(match, groups);
            }
        }
    }

    // ---------------------------------

    // embed current styling into original HTML and return result
    buildStyledHTML() {

        if (this.styling.length === 0) {
            return this.original;
        }

        return buildStyledHTML(this.original, this.styling);
    }
}

// -----------------------------------------------------------------------------
/*

find and erase whitespace/html
find and erase comments
find and erase character/string literals - end of line or line continuation

find integer/floating-point literals
find pre-processor commands
find keywords
find function/struct/enum/union definitions

list pre-processor defines
list functions and parameters
list local variables
list global variables
list typedefs

function findClosingDelimiter(text, opensAt, opener, closer) {

    let closesAt = opensAt;
    do {

        closesAt = text.indexOf(closer, closesAt + closer.length);
        if (closesAt < 0) {
            closesAt = text.length;
        }

        opensAt = text.indexOf(opener, opensAt + opener.length);
        if (opensAt < 0) {
            opensAt = text.length;
        }

    } while (opensAt < closesAt);

    return closesAt;
}

class CodeBlock {

    constructor(opensAt, closesAt) {

        this.opensAt    = opensAt;
        this.closesAt   = closesAt;
        this.name       = "";
        this.parameters = [];
    }

    setParameters(parameters) {

        const getParameter = /([A-Za-z_]\w*)\s*$/;

        this.parameters = parameters.split(",");
        let i = 0;
        while (i < this.parameters.length) {

            const groups = getParameter.exec(this.parameters[i]);
            if (groups === null) {
                this.parameters.splice(i, 1);
                continue;
            }

            this.parameters[i] = groups[1];
            i++;
        }
    }
}

function findCodeBlocks(string, keywords) {

    const getDetails = /([A-Za-z_]\w*)(?:\s*\(([^\)]*)\))?\s*\{/g;

    let   groups = getDetails.exec(string);
    const blocks = [];

    let closesAt;
    for (let opensAt = string.indexOf("{");
             opensAt !== -1;
             opensAt = string.indexOf("{", closesAt + 1)) {

        closesAt = findClosingDelimiter(string, opensAt, "{", "}");
        blocks.push(new CodeBlock(opensAt, closesAt));

        while (groups !== null &&
               getDetails.lastIndex < blocks.at(-1).opensAt + 1) {
            groups = getDetails.exec(string);
        }

        if (getDetails.lastIndex === blocks.at(-1).opensAt + 1 &&
            !keywords.includes(groups[1])) {

            blocks.at(-1).name = groups[1];
            if (groups.length > 2) {
                blocks.at(-1).setParameters(groups[2]);
            }
        }
    }

    return blocks;
}

while top level
    check each function tag
    scope to parameter list
    get list of parameter names
    if immediately before function body
        *scope to function body
        *get list of local variables
        merge with list of parameter names
        scope to parameter list + function body
    color-code local variables



color-code all comments - hide
    single line
    multi-line
color-code all literals - obfusticate
    character
    string
    integer
    floating point
color-code all preprocessor directives - obfusticate
    create list of macro names - color-code, but scoped
    update list based on #undef
color-code all keywords - obfusticate


for each code segment:
----------------------
color-code function names
    create list of function names
find struct, enum, and union names - split struct/union from enum
    handle anonymous composites
    handle nested composites - inside each other and inside functions
    update global/local lists of composite names - color-code
    update global/local lists of enum item names - color-code
find parameter and variable names
    handle known data types
    handle typedefs
    update global/local lists of parameter/variable names - color-code
    update global/local lists of typedef names - color-code


class ScopeBlock {

    constructor() {
        this.type  = type;  // function or enum
        this.start = start;
        this.stop  = stop;
    }
}


class ScopedName {

    constructor(token, style, start, stop) {
        this.token = token;  // what to match
        this.style = style;  // style to use when matched
        this.start = start;  // where token first declared
        this.stop  = stop;   // defaults to string.length
    }
}



color-code single line comments
color-code multi-line comments
color-code character literals
color-code string literals
color-code integer and floating-point literals
color-code preprocessor directives
locate #defines, for each with macro:
    locate matching #undef
    color-code macro name between #define and #undef (or end of text)
color-code keywords

scope object:
    has start
    has end

create array for function scope objects
locate functions, for each:
    color-code function name throughout text
    if exists function body:
        add to function scope array
    if exists parameter list:
        color-code parameter names within list (plus function body if exists)

create array for definition scope objects
locate structs, unions, and enums, for each:
    color-code name immediately after keyword
    if exists body:
        add to definition scope array

token object extends scope object:
    adds text
    adds style

create array for style token objects
locate enums, for each:
    if enum within function scope, end is end of scope, else end is end of text
    locate enum item names, for each:
        add to style token array with appropriate end

create array for type token objects
locate typedefs, for each:
    if typedef within local scope, end is end of scope, else end is end of text
    add to style token array with appropriate end
    add to type token array with appropriate end






color-code single line and multi-line comments
color-code character literals and string literals
color-code integer and floating-point literals
color-code preprocessor directives
locate #includes, for each with file:
    color-code file name within angle brackets same as string literal
locate #defines, for each with macro:
    locate matching #undef
    color-code macro name between #define and #undef (or end of text)
color-code keywords

scope object:
    has start
    has end

create array for definition scope objects - for typedefs and variables
locate structs, unions, and enums, for each:
    color-code name immediately after keyword
    if exists body:
        add to definition scope array

token object extends scope object:
    adds text
    adds style
    adds local/global flag

create array for function scope objects
create array for style token objects
locate functions, for each:
    add name to style token array as global
    if exists function body:
        add to function scope array
    if exists parameter list:
        locate parameter list names, for each:
            add to style token array as local (include list indices)
locate enums again, for each:
    if enum within function scope, use local, else use global
    locate enum item names, for each:
        add to style token array as local/global

create temp version of text with definition scope objects hidden
create array for type token objects
locate typedefs, for each:
    if typedef within function scope, use local, else use global
    add to type token array as local/global
create regex for all known data types:
    include keyword types, struct/union/enum/typedef, and all typedef types
locate possible variables, for each:
    if contains keyword typedef, discard
    if using typedef type but type not in scope, discard



const preprocessorDirectives = [
    "define",
    "elif",
    "elifdef",
    "elifndef",
    "else",
    "embed",
    "endif",
    "error",
    "if",
    "ifdef",
    "ifndef",
    "include",
    "line",
    "pragma",
    "undef",
    "warning"
];

const keywords = [
];

const lineBreakRegex      = /<\/?div>|<br>/;
const commentRegex        = /\/\/.*?<\/?div>|\/\*.*?\*\//g;
const numericLiteralRegex = /-?\.?\d[A-Za-z\d.-]*/g;             /*
const textLiteralRegex    =
    /\w{0,3}(['"]).*?(?<!\\<\/div>|.{6}\\)(?:\1|<div>)/g;

const includeFileRegex  = /#\s*include\s+(&lt;.*?(?:&gt;|<\/?div>))/g;
const macroRegex        = /#\s*define\s+([A-Za-z_]\w*)/g;
const preprocessorRegex = new RegExp(
    "#\\s*(?:" + preprocessorDirectives.join("|") + "))\\b", "g");

const typeTagRegex = //g;
const keywordRegex = new RegExp(
    );



Single and Multi-Line Comments
String and Character Literals
Include Files in Angle Brackets

Floating-Point Literals
Integer Literals
Preprocessor Directives
Preprocessor Macros - TEST FIRST!
Keywords
Struct/Union/Enum Tag Names - TEST FIRST!

Function Names, Function Parameters, Enum Constants
Global Variables, Local Variables, Typedef Names

Handle Scoping

class scope {

    constructor(start, end, parameters) {
        this.start      = start;
        this.end        = end;
        this.parameters = parameters;
    }
}

string.replace(/\{[^}]*\}/g, "{ }");
string.replace(/\([^,)]*,[^)]*\)/g, "( )");



while "done" flag not set
  regex from last index using /([A-Za-z_]\w*)\s*([{[=,;]/g
  for case "{":
    find matching closer
    move last index to closer position
  for case "[":
    if "ignore" flag not set
      add identifier to temp list
      set "ignore" flag
    find matching closer
    move last index to closer position
  for case "=":
    if "ignore" flag not set
      add identifier to temp list
      set "ignore" flag
  for case ",":
    if "ignore" flag not set
      add identifier to temp list
    clear "ignore" flag
  for case ";":
    if "ignore" flag not set
      add identifier to temp list
    set "done flag"

const regex = /([A-Za-z_]\w*)\s*([{[=,;])/g;

const tempList = [];
let   ignore   = false;
let   match    = regex.exec(string);

while (match !== null) {

    switch (match[2].charAt(0)) {

        case '{': 
            regex.lastIndex = matchDelim(string, regex.lastIndex, "{", "}");
            break;

        case '[':
            regex.lastIndex = matchDelim(string, regex.lastIndex, "[", "]");
            // fall through to next case...

        case '=':
            if (!ignore) {
                tempList.push(match[1]);
                ignore = true;
            }
            break;

        case ',':
            if (!ignore) {
                tempList.push(match[1]);
            } else {
                ignore = false;
            }
            break;

        case ';':
            if (!ignore) {
                tempList.push(match[1]);
            }
            match = null;
            continue;
    }

    match = regex.exec(string);
}

const fullLine = string.substring(startIndex, regex.lastIndex);

if (fullLine.indexOf("typedef") !== -1) {
    addTypes(tempList);
} else {
    addVariables(tempList);
}

*/
// -----------------------------------------------------------------------------
// all regular expressions confined to this section

// matches HTML-encoded line breaks
const splitAcrossLines = /<\/?div>|<br>/;

// -------------------------------------

// convert list of identifiers into a regular expression
function regexFromList(list) {

    // must work for preprocessor directives
    return new RegExp("(?<![#\\w])(?:" + list.join("|") + ")\\b", "g");
}

// build a regular expression which matches variable names
// passing "typedef" as trigger builds regex for typedefs
// can pass multiple delimiter characters like "[;=]"
function regexForVariables(trigger, delimiter = ";") {

    let triggerOn = trigger;  // assume trigger is string
    if (Array.isArray(trigger)) {

        // construct list of known data types
        triggerOn = dataType.join("|");
        if (trigger.length > 0) {
            triggerOn += "|" + trigger.join("|");  // add triggers
        }

        // wrap list as non-capturing group
        triggerOn = "(?:" + triggerOn + ")";
    }

    // match valid variable name, ignoring whitespace and modifiers
    return new RegExp(
        triggerOn                 +  // starts with triggering match
        "[^()]*?([A-Za-z_]\\w*)"  +  // capture last token of match
        "(?:\\s|<\\/?div>|<br>)*" +  // possible whitespace after token
        delimiter, "g");             // match ends with delimiter
}

// -------------------------------------

// strip previously applied styles
function unstyledFromStyled(html) {

    return html
        .replace(/<span[^>]*>/g, "")
        .replace(/<font[^>]*>/g, "")  // added by some browsers
        .replace(/<\/span>/g,    "")
        .replace(/<\/font>/g,    "");
}

// convert HTML into plain text
function textFromHTML(html) {

    let text = unstyledFromStyled(html)
        .replace(/<div>/g,        "\n")
        .replace(/<\/div>|<br>/g, "")
        .replace(/&lt;/g,         "<")
        .replace(/&gt;/g,         ">");

    // first text element may or may not be inside a <div>
    if (text[0] == "\n") {
        text = text.substring(1);  // chop off extra newline
    }

    return text;
}

// convert plain text into unstyled HTML
function htmlFromText(text) {

    const cleanText = text
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");

    // if it might be a line break, it's a line break
    const lines = cleanText.split(/\r*\n|\r/);
    if (lines.length < 2) {
        return lines[0];
    }

    let html = "";
    for (let i = 0; i < lines.length; i++) {

        if (lines[i].length < 1) {
            lines[i] = "<br>";  // required for empty lines
        }
        html += "<div>" + lines[i] + "</div>";
    }

    return html;
}

// -------------------------------------

function styleCommentsAndLiterals(styler) {

    // color-code C-style comments
    styler.updateMatchedText(
        /\/\*.*?\*\//g,    // regex to match against
        "comment",         // which CSS style to apply
        splitAcrossLines,  // ensure HTML tags are nested correctly
        "", "");           // hide text from further examination

    // color-code character literals and strings
    styler.updateMatchedText(
        /(['"]).*?(?<!\\<\/div>|.{6}\\)(?:\1|<div>)/g,
        "literal",
        splitAcrossLines,
        "$", "$");  // mark hidden text with dollar signs at either end

    // color-code numbers
    styler.updateMatchedText(/-?\.?\d[A-Za-z\d\-\.]*/g, "literal");
}

// -------------------------------------

function stylePreprocessorDirectives(styler) {

    // color-code most preprocessor directives
    styler.updateMatchedText(
        regexFromList(preprocessor),  // build regex from list
        "preprocessor");

    // color-code "#define" directives
    const groups = [null, [] ];  // only return 2nd capture group
    styler.findCaptureGroups(
        /(#define)\s+([A-Za-z_]\w*)/g,
        ["preprocessor"],  // style for 1st capture group
        groups);

    // color-code any macros retrieved in previous step
    if (groups[1].length > 0) {

        styler.updateMatchedText(
            regexFromList(groups[1]),  // build regex from list
            "macro",
            null,       // macros are all single tokens
            "$", "$");  // mark hidden text with dollar signs
    }
}

// -------------------------------------

function styleKeywords(styler) {

    // color-code most keywords
    styler.updateMatchedText(
        regexFromList(keyword),
        "keyword",
        null,       // keywords are all single tokens
        "$", "$");  // mark hidden text with dollar signs at either end

    // color-code data type keywords
    styler.updateMatchedText(regexFromList(dataType), "keyword");

    // matches struct/enum/union names (also captures matched keyword)
    const captureComposites = new RegExp(
        "(" + composite.join("|") + ")" +  // keywords to match
        "(?:\\s|<\\/?div>|<br>)+" +        // whitespace
        "([A-Za-z_]\\w*)", "g");           // token to capture

    // color-code composite data types
    const styles = ["keyword", "userDefined"];
    styler.findCaptureGroups(captureComposites, styles);
}

// -------------------------------------

// find closing match for given pair of symbols
function findClosingDelimiter(text, opensAt, opener, closer) {

    let closesAt = opensAt;
    do {

        closesAt = text.indexOf(closer, closesAt + closer.length);
        if (closesAt < 0) {
            closesAt = text.length;
        }

        // overwrite passed-in value
        opensAt = text.indexOf(opener, opensAt + opener.length);
        if (opensAt < 0) {
            opensAt = text.length;
        }

    // doesn't use <= because potential for infinite loop
    } while (opensAt < closesAt);

    return closesAt;
}

function styleLocalVariables(styler, parameters) {

    // confirm has function body
    const text = styler.edited.substring(parameters.stop);
    if (text.search(/(?:\s|<\/?div>|<br>)*\{/) !== 0) {
        return;
    }

    // scope down to just parameter list
    styler.setScope(parameters.start, parameters.stop);

    // find parameter names
    const groups = [ [] ];  // return 1st (and only) capture group
    styler.findCaptureGroups(
        /\b(\w+)(?:\s|<\/?div>|<br>)*(?:,|\))/g,
        ["variable"],  // style for names in parameter list
        groups);

    // confirm has at least one parameter
    if (groups[0].length < 1) {
        return;
    }

    // change scope to function body
    const opensAt = text.indexOf("{");
    styler.setScope(
        parameters.stop + opensAt,
        parameters.stop + findClosingDelimiter(text, opensAt, "{", "}"));

    // color-code parameter names
    styler.updateMatchedText(
        regexFromList(groups[0]),
        "variable");

    styler.clearScope();
}

function styleFunctions(styler) {

    // find functions and their parameter lists
    const groups = [ [] ];               // only return 1st capture group
    const styles = [ "", "parameters"];  // temp style for 2nd group
    styler.findCaptureGroups(
        /([A-Za-z_]\w*)(?:\s|<\/?div>|<br>)*\((.*?\))/g,
        styles,
        groups);

    // confirm has at least one function
    if (groups[0].length < 1) {
        return;
    }

    // color-code function names
    styler.updateMatchedText(
        regexFromList(groups[0]),
        "function");

    // extract parameter list Styling objects from styler
    const parameters = styler.styling
        .filter(function(s) { return s.style === styles[1]; });
    styler.removeStyling(styles[1]);

    // find and color-code variable names within each function
    for (let i = 0; i < parameters.length; i++) {
        styleLocalVariables(styler, parameters[i]);
    }
}

// -------------------------------------

// saves and restores text caret after updating inner HTML
// should probably be rewritten to count <div> tags or something
function preserveCaret(element, html) {

    const selection = window.getSelection();
    if (!selection || selection.rangeCount < 1) {
        element.innerHTML = html;
        return;
    }

    const range = selection.getRangeAt(0).cloneRange();
    range.setStart(element, 0);
    let caret = range.toString().length;

    element.innerHTML = html;

    const tree = document.createTreeWalker(element, NodeFilter.SHOW_TEXT);
    while (tree.nextNode() && caret > tree.currentNode.length) {
        caret -= tree.currentNode.length;
    }
    caret = Math.min(caret, tree.currentNode.length);

    range.setStart(tree.currentNode, caret);
    range.collapse(true);
    selection.removeAllRanges();
    selection.addRange(range);
}

// apply styling step-by-step and display for user
function styleEditBox() {

    const editBox = document.getElementById("editBox");
    const html    = unstyledFromStyled(editBox.innerHTML);
    const styler  = new StyleBuilder(html);

    styleCommentsAndLiterals(styler);
    stylePreprocessorDirectives(styler);
    styleKeywords(styler);
    styleFunctions(styler);

    // apply styling and update edit box
    preserveCaret(editBox, styler.buildStyledHTML());
}

// -----------------------------------------------------------------------------

let hasChanges = false;  // edit box dirty flag
let stylingTimer;        // timer ID for debouncing

// -------------------------------------

// EVENT LISTENER - attached by initialize()
// after no input for 2 seconds, update styles used in edit box
function debounceStyling() {

    hasChanges = true;

    // restart timer
    clearTimeout(stylingTimer);  // silently errors on invalid timer ID
    stylingTimer = setTimeout(styleEditBox, 2000);
}

function confirmDropChanges() {

    return !hasChanges ||
           confirm("You will lose any unsaved changes.");
}

// reset edit box to starting conditions
function clearEditBox() {

    if (!confirmDropChanges()) {
        return;
    }

    document.getElementById("editBox").innerHTML = "";
    document.getElementById("fileName").value    = "temp.txt";
    hasChanges                                   = false;
}

// -------------------------------------

// trigger hidden file picker control
function pickFile() {

    if (!confirmDropChanges()) {
        return;
    }

    document.getElementById("filePicker").click();
}

// EVENT LISTENER - attached by readFile()
// convert file to HTML, load, and style
function loadFile(text) {

    document.getElementById("editBox").innerHTML = htmlFromText(text);

    styleEditBox();
    hasChanges = false;
}

// EVENT LISTENER - attached by initialize()
// read selected file and load into edit box
function readFile() {

    if (this.files.length < 1) {
        return;  // file picker cancelled!
    }

    let fileName = this.files[0].name;
    if (fileName.indexOf(".") < 0) {
        fileName += ".";
    }
    document.getElementById("fileName").value = fileName;

    const reader = new FileReader();
    reader.addEventListener("load", function () {
        loadFile(reader.result);
    });

    reader.readAsText(this.files[0]);
    this.value = "";  // clear file picker
}

// -------------------------------------

// package up file and simulate clicking download link
function dispatchFile(name, type, content) {

    const file = new Blob([content], { type: type });
    const url  = URL.createObjectURL(file);

    const link    = document.createElement("a");
    link.href     = url;
    link.download = name;  // set file name

    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    URL.revokeObjectURL(url);  // clean up temp URL
}

// determine file name and official "type" of download
function downloadFile() {

    let type = "text/plain";
    let name = document.getElementById("fileName").value;
    if (name.indexOf(".") < 0) {
        name += ".txt";  // append default extension
    }

    else if (name.at(-1) == ".") {
        name = name.substring(0, name.length - 1);  // chop off period
        type = "application/octet-stream";  // prevent default extension
    }

    const editBox = document.getElementById("editBox");
    const content = textFromHTML(editBox.innerHTML);

    dispatchFile(name, type, content);  // package file and dispatch
    hasChanges = false;
}

// -------------------------------------

// attach event listeners and prep edit box for user
function initialize() {

    document
        .getElementById("filePicker")
        .addEventListener("change", readFile);

    document
        .getElementById("editBox")
        .addEventListener("input", debounceStyling);

    clearEditBox();
}

// -----------------------------------------------------------------------------
    </script>

</head>
<body onload="initialize()">

    <div class="viewPort">
        <div class="toolBar">

            <input type="button"
                   value="New File"
                   onclick="clearEditBox()">

            <!-- invisible and hidden behind other controls -->
            <input type="file"
                   id="filePicker"
                   accept="text/plain">

            <!-- triggers file picker above -->
            <input type="button"
                   value="Open File"
                   onclick="pickFile()">

            <input type="button"
                   value="Save to Downloads"
                   onclick="downloadFile()">

            <label for="fileName">Current File:</label>
            <input type="text"
                   id="fileName">

        </div>
        <div id="editBox"
             contenteditable="true"
             spellcheck="false"></div>
    </div>

</body>
</html>







