<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0">

    <title>Keyword Highlighter</title>

    <style>
/* -------------------------------------------------------------------------- */

body, input {
    font-family: "Courier New", Courier, monospace;
    font-size:   12pt;
}

/* top-level flexbox */
#container {
    display:        flex;
    flex-direction: column;      /* toolbar above editbox */
    width:          85vw;
    height:         85vh;
    margin:         1.5em auto;  /* center horizontally */
}

/* typing area */
#editbox {
    flex-grow:   1;     /* fill majority of flexbox */
    white-space: preserve nowrap;
    overflow:    auto;  /* add scrollbars if/when needed */
    padding:     0.6em 0.8em;
    border:      0.1em solid black;
    outline:     none;
}

/* container for interface controls */
#toolbar {
    flex-grow: 0;         /* minimize footprint */
    position:  relative;  /* to position file picker */
}

/* hidden behind other controls */
#filePicker {
    position: absolute;
    z-index:  -1;
    opacity:  0;  /* also invisible */
}

/* container for filename textbox and its label */
#currentFile {
    display: inline-block;
}

#filename {
    width:   40em;
    outline: none;
}

/* add space between interface controls when arranged vertically */
input {
    margin: 0 0 0.4em;
}

#caretPosition {
    display: inline-block;
    margin:  0 0 0.8em;  /* add space between toolbar and editbox */
}

/* -------------------------------------------------------------------------- */
/* colors for keywords, literals, variables, etc. */

#editbox { background-color: #F9F9F9; }  /* off white */

.keyword        { color: #1010FF; }  /* blue   */
.literal        { color: #D00000; }  /* red    */
.localVariable  { color: #E717E7; }  /* pink   */
.globalVariable { color: #E76700; }  /* orange */
.tagType        { color: #009797; }  /* teal   */
.enumConstant   { color: #9000C0; }  /* purple */
.typedef        { color: #009797; }  /* teal   */
.function       { color: #E76700; }  /* orange */
.parameter      { color: #6B6B6B; }  /* gray   */
.preprocessor   { color: #6B6B6B; }  /* gray   */
.macro          { color: #9000C0; }  /* purple */
.comment        { color: #009000; }  /* green  */

/* -------------------------------------------------------------------------- */
    </style>
    <script>
// -----------------------------------------------------------------------------
// keyword lists

const preprocessorDirectives = [
    "define",
    "undef",
    "if",
    "ifdef",
    "ifndef",
    "else",
    "elif",
    "elifdef",
    "elifndef",
    "endif",
    "include",
    "embed",
    "warning",
    "error",
    "line",
    "pragma"
];

const dataTypes = [
    "int",
    "short",
    "long",
    "signed",
    "unsigned",
    "float",
    "double",
    "char",
    "wchar_t",
    "bool",
    "void",
    "struct",
    "union",
    "enum",
    "typedef"
];

const otherKeywords = [
    "auto",
    "const",
    "static",
    "extern",
    "register",
    "volatile",
    "if",
    "else",
    "switch",
    "case",
    "default",
    "break",
    "do",
    "while",
    "for",
    "continue",
    "sizeof",
    "goto",
    "return"
];

// -----------------------------------------------------------------------------
// regular expressions

const newlineRegex   = /\r*\n|\r/g;
const linebreakRegex = /<\/?div>|<br>/;   // global flag not needed
const emptyLineRegex = /<div><\/div>/g;   // missing <br> tags
const filenameRegex  = /[\\\/:*?"<>|]/g;  // common invalid symbols

// some browsers insert <font> tags during editing
const stylingRegex = /<\/?span[^>]*>|<\/?font[^>]*>/g;

// matches both single and multi-line comments
const commentRegex = /\/\/.*?(?:<\/?div>|$)|\/\*.*?\*\//g;
const numberRegex  = /(?<![A-Za-z_])-?\.?\b\d[A-Za-z\d.-]*/g;

// matches both character and string literals
// also allows for line continuation
const stringRegex =
    /(?:L|U|u|u8)?(['"]).*?(?<!\\<\/div>|.{6}\\)(?:\1|<div>)/g;

const includeFileRegex  = /#\s*include\s+(&lt;.*?(?:&gt;|<\/?div>))/g;
const macroRegex        = /#\s*define\s+([A-Za-z_]\w*)/g;
const preprocessorRegex = new RegExp(
    "#\\s*(?:" + preprocessorDirectives.join("|") + ")\\b", "g");

const keywordRegex = new RegExp(
    "\\b(?:" + dataTypes.join("|") + "|" +
           otherKeywords.join("|") + ")\\b", "g");

// both of these match entire statement from data type to semicolon
const enumRegex     = /\benum\b[^;]*;/g;
const dataTypeRegex = new RegExp(
    "\\b(?:" + dataTypes.join("|") + ")\\b[^;]*;", "g");

// update data type regex to include newly found typedefs
function expandDataTypeRegex(typedefs, previous) {

    const begin = "\\b(?:";
    const end   = ")\\b[^;]*;";

    // combine previously found data types with new typedefs
    const combined = previous.source
        .replace(begin, "")
        .replace(end,   "") + "|" + typedefs.join("|");

    const regex     = new RegExp(begin + combined + end, "g");
    regex.lastIndex = previous.lastIndex;  // carry over last index

    return regex;
}

// -------------------------------------

// create regex from multiple patterns with whitespace in between
function createPatternRegex(patterns) {

    // might have whitespace, or patterns might run together
    const whitespace = "(?:\\s|</?div>|<br>)*";

    let sequence = "";
    for (let i = 0; i < patterns.length - 1; i++) {
        sequence += patterns[i] + whitespace;
    }

    // add final pattern to end and return as global regex
    return new RegExp(sequence + patterns[patterns.length - 1], "g");
}

// pattern for capturing identifier tokens
const identifierToken = "\\b([A-Za-z_]\\w*)";

// PATTERN: enum/struct/union followed by identifier
const tagTypeRegex = createPatternRegex(
    [ "\\b(?:enum|struct|union)", identifierToken ]);

// PATTERN: struct/union followed by optional identifer and open brace
const compositeRegex = createPatternRegex(
    [ "\\b(?:struct|union)", identifierToken + "?", "\\{" ]);

// PATTERN: optional identifier followed by one of: {[=&,;
// semicolon terminates declaration
// ampersand needed to avoid matching HTML entities
const variableRegex = createPatternRegex(
    [ identifierToken + "?", "([{[=&,;])" ]);

// PATTERN: optional identifier followed by one of: [,)
// closed parenthesis terminates declaration
const parameterRegex = createPatternRegex(
    [ identifierToken + "?", "([[,)])" ]);

// PATTERN: optional identifier followed by one of: =,}
// closed brace terminates declaration
const enumConstantRegex = createPatternRegex(
    [ identifierToken + "?", "([=,}])" ]);

// PATTERN: identifier followed by open parenthesis
const functionRegex = createPatternRegex(
    [ identifierToken, "\\(" ]);

// PATTERN: identifier followed by text in parentheses and open brace
const localScopeRegex = createPatternRegex(
    [ identifierToken, "\\([^)]*\\)", "\\{" ]);

// PATTERN: open parenthesis followed by asterisk, identifier,
//              closed parenthesis, and second open parenthesis
const callbackRegex = createPatternRegex(
    [ "\\([^*)]*\\*", identifierToken, "\\)", "\\(" ]);

// -----------------------------------------------------------------------------
// global data

// current text to be styled
// modified at various points to simplify regex matching
let text = "";

// specific region of current text
class Scope {

    constructor(start = 0, stop = 0) {
        this.start = start;
        this.stop  = stop;  // first index outside of scope
    }

    set(start, stop) {
        this.start = start;
        this.stop  = stop;
    }

    // target entirety of current text
    clear() {
        this.start = 0;
        this.stop  = text.length;
    }
}

// region of current text to apply given style
class Style extends Scope {

    constructor(style, start, stop) {
        super(start, stop);
        this.style = style;  // used to create <span> tag
    }
}

// content of separate file to also scan during styling
// used to load header files and import macros, typedefs, etc.
class Context {

    constructor(filename, fileData = "") {
        this.filename = filename;
        this.fileData = fileData;
    }
}

const contexts = [];           // array of Context objects
const styles   = [];           // array of Style objects
const scope    = new Scope();  // indices of current local scope
const search   = new Scope();  // indices of current search scope

// -------------------------------------

// prepare for next styling pass
function initializeGlobals(html) {

    const unstyled = html
        .replace(stylingRegex,   "")
        .replace(newlineRegex,   "</div><div>")
        .replace(emptyLineRegex, "<div><br></div>");

    text          = unstyled;
    styles.length = 0;   // discard previous Style objects
    scope.clear();
    search.clear();

    return unstyled;
}

// is region outside of any existing Style object?
function canStyle(start, stop) {

    for (let i = 0; i < styles.length; i++) {

        if (start < styles[i].stop && stop > styles[i].start) {
            return false;  // cannot style - regions would overlap
        }
    }

    return true;  // could style - no overlap
}

// create Style object from parameters and append to end of array
function addStyle(style, start, stop) {

    styles.push(new Style(style, start, stop));
}

// build finished text based on current styling
// needs fresh copy of text without modifications
function applyStyles(unstyled) {

    if (styles.length === 0) {
        return unstyled;  // no styles to apply
    }

    // create shorter name for String.substring() calls
    const mid = unstyled.substring.bind(unstyled);
    styles.sort(function(a, b) {
        return a.start - b.start; });  // sort by starting index

    let html = mid(0, styles[0].start);  // text before first Style
    for (let i = 0; i < styles.length; i++) {

        // wrap target text with <span> tag
        html += "<span class='" + styles[i].style + "'>" +
                mid(styles[i].start, styles[i].stop)     +
                "</span>";

        // copy text between current Style and next Style
        if (i + 1 < styles.length) {
            html += mid(styles[i].stop, styles[i + 1].start);
        } else {
            html += mid(styles[i].stop);  // text after last Style
        }
    }

    return html;
}

function getContext(filename) {

    let context = contexts.find(function(c) {
        return c.filename === filename; });

    if (context !== undefined) {
        return context;
    } else {

        context = new Context(filename);
        contexts.push(context);
        return context;
    }
}

// -----------------------------------------------------------------------------
// style entire regex match

// action functions are passed as arguments to filter functions
// filter functions execute regex and call action for each match found

// ACTION: add to styles array, but prevent overlapping regions
function addMatch(style, start, stop) {

    if (canStyle(start, stop) === false) {
        return false;  // cannot add - text already styled
    }

    addStyle(style, start, stop);
    return true;  // style added successfully
}

// ACTION: add to styles array, but also account for line breaks
function splitMatch(style, start, stop) {

    if (canStyle(start, stop) === false) {
        return false;  // cannot add - text already styled
    }

    // break regex match into lines
    const lines = text
        .substring(start, stop)
        .split(linebreakRegex)
        .filter(function(s) {
            return s.length > 0; });  // remove empty strings

    stop = start;  // needed for first iteration
    for (let i = 0; i < lines.length; i++) {

        // find current line in original text
        start = text.indexOf(lines[i], stop);
        stop  = start + lines[i].length;

        addStyle(style, start, stop);  // add styling
    }

    return true;  // style(s) added successfully
}

// ACTION: add to styles array, but also hide from future searches
function hideMatch(style, start, stop) {

    if (splitMatch(style, start, stop) === false) {
        return;  // cannot add - text already styled
    }

    // replace regex match with spaces
    text = text.substring(0, start) +  // text before match
           " ".repeat(stop - start) +  // same number of characters
           text.substring(stop);       // text after match
}

// FILTER: apply style using given action for each regex match
function styleMatches(style, action, regex) {

    regex.lastIndex = search.start;  // respect search scope

    for (let match = regex.exec(text);
             match !== null;
             match = regex.exec(text)) {

        const stop  = match.index + match[0].length;
        if (stop > search.stop) {
            break;  // respect search scope
        }

        action(style, match.index, stop);
    }
}

// use temporary regex to apply style to each match
// "tokens" can be either single token or pre-joined string of tokens
function quickStyle(style, tokens) {

    // confirm valid token list provided
    if (tokens !== "") {

        const regex = new RegExp("\\b(?:" + tokens + ")\\b", "g");
        styleMatches(style, addMatch, regex);
    }
}

// -----------------------------------------------------------------------------
// style first capture group

// ACTION: try to style first capture group and report success/failure
function addGroup(style, match) {

    // extract token from match and remove any stray linebreaks
    const token = match[1].replace(linebreakRegex, "");

    // find token within full text
    const start = match.index + match[0].indexOf(token);
    const stop  = start + token.length;

    return addMatch(style, start, stop);  // try to style
}

// search for #undef declaration matching given token
function findUndef(token, start, style) {

    // build regex around provided token
    const regex = new RegExp("#\\s*undef\\s+(" + token + ")\\b", "g");

    regex.lastIndex = start;  // start at end of original #define

    for (let match = regex.exec(text);
             match !== null;
             match = regex.exec(text)) {

        // confirm matching #undef is outside comment/string/etc.
        if (addGroup(style, match) === true) {

            // matching #undef found!
            return match.index;
        }
    }

    return text.length;  // no matching #undef - use end of file
}

// ACTION: check potential macro and style within its valid scope
function addMacro(style, match) {

    // check if macro defined outside comment/string/etc.
    if (addGroup(style, match) === false) {
        return;  // macro not valid - text already styled
    }

    // limit next search to macro's valid scope
    // match[1] is capture group with macro token
    const start = match.index + match[0].length;
    search.set(
        start,
        findUndef(match[1], start, style));

    // search for macro and apply style
    quickStyle(style, match[1]);
    search.clear();  // remove search limit set above
}

// ACTION: check potential function name and style if valid
function addFunction(style, match) {

    // check if function name outside comment/string/etc.
    if (addGroup(style, match) === false) {
        return;  // function name not valid - text already styled
    }

    // match[1] is capture group with function name
    quickStyle(style, match[1]);
}

// FILTER: apply style using given action for each regex match
function styleGroups(style, action, regex) {

    for (let match = regex.exec(text);
             match !== null;
             match = regex.exec(text)) {

        action(style, match);
    }
}

// -----------------------------------------------------------------------------
// style identifier tokens

// find matching bracket/brace for symbol just before starting index
function findCloser(start, opener, closer) {

    start--;           // back up to original opener
    let stop = start;  // needed for first iteration
    do {

        // find next closing symbol
        stop = text.indexOf(closer, stop + closer.length);
        if (stop === -1) {
            stop = text.length - 1;  // nothing left to match
        }

        // find next opening symbol
        start = text.indexOf(opener, start + opener.length);
        if (start === -1) {
            start = text.length - 1;  // nothing left to match
        }

    // start is less than stop only when current opener is nested
    // if nested, current closer cannot match with original opener
    } while (start < stop);

    // return index after matching closer, or text.length if no match
    return stop + 1;
}

// add token to array if outside any existing Style object's region
function addToken(match, tokens) {

    // match[1] is identifier token
    if (match[1] !== undefined &&  // token may have been optional
        canStyle(
            match.index,
            match.index + match[1].length) === true) {

        tokens.push(match[1]);  // add to provided array
    }
}

// extract valid identifier tokens within current search region
function findTokens(regex) {

    // collect tokens in local array
    const tokens = [];
    let   canAdd = true;  // add next token?

    regex.lastIndex = search.start;  // respect search scope

    for (let match = regex.exec(text);
             match !== null;
             match = regex.exec(text)) {

        const stop = match.index + match[0].length;
        if (stop > search.stop) {
            break;  // respect search scope
        }

        switch (match[2]) {  // match[2] is symbol after token

            // regex parameter limits which of these cases get used

            // skip any text inside braces
            case "{":
                regex.lastIndex = findCloser(regex.lastIndex, "{", "}");
                break;

            // add token in front of brackets
            // but skip any text inside brackets
            case "[":
                if (canAdd === true) {        // first match only
                    addToken(match, tokens);  // add identifier token
                    canAdd = false;
                }
                regex.lastIndex = findCloser(regex.lastIndex, "[", "]");
                break;

            // add token in front of equals sign
            case "=":
                if (canAdd === true) {        // first match only
                    addToken(match, tokens);  // add identifier token
                    canAdd = false;
                }
                break;

            // nothing after ampersand is valid token
            case "&":
                canAdd = false;  // disable matching
                break;

            // add token in front of comma
            case ",":
                if (canAdd === true) {        // first match only
                    addToken(match, tokens);  // add identifier token
                }
                canAdd = true;  // reset matching flag
                break;

            // add token in front of declaration terminator
            case ";":  // for variables and typedefs
            case ")":  // for parameters
            case "}":  // for enumerations
                if (canAdd === true) {        // first match only
                    addToken(match, tokens);  // add identifier token
                }
                return tokens;  // declaration finished
        }
    }

    return tokens;  // no declaration terminator found
}

// -------------------------------------

// ACTION: extract typedefs from match - first parameter ignored
function findTypedefs(unused, match, regex) {

    // determine if match is actually typedef declaration
    if (match[0].indexOf("typedef") !== -1) {

        // extract list of typedefs
        search.set(match.index, match.index + match[0].length);
        const tokens = findTokens(regex);
        search.clear();

        return tokens;  // return new typedefs
    }

    return "";  // no typedefs to return
}

// ACTION: find identifier tokens and style within current scope
function styleTokens(style, match, regex) {

    // extract list of tokens
    search.set(match.index, match.index + match[0].length);
    const tokens = findTokens(regex);

    // apply style through end of current scope
    search.stop = scope.stop;
    quickStyle(style, tokens.join("|"));
    search.clear();

    return tokens;  // needed for typedef handling
}

// ACTION: find variables and typedefs and style within current scope
// "style" parameter is array of strings
function styleVariables(style, match, regex) {

    // determine if match is typedef or variable declaration
    if (match[0].indexOf("typedef") !== -1) {

        // style typedefs and return identifier tokens
        return styleTokens(style[1], match, regex);

    } else {

        // style variables and return empty string
        styleTokens(style[0], match, regex);
        return "";  // no typedefs to return
    }
}

// FILTER: apply style using given action to each matching phrase
function styleIdentifiers(style, action, phrase, regex, expand = false) {

    phrase.lastIndex = scope.start;  // respect current scope

    // locate match for phrase regex within current text
    for (let match = phrase.exec(text);
             match !== null;
             match = phrase.exec(text)) {

        const stop = match.index + match[0].length;
        if (stop > scope.stop) {
            break;  // respect current scope
        }

        // apply action to matching phrase using second regex
        const tokens = action(style, match, regex);

        // optionally expand phrase regex with any new typedefs found
        if (expand === true && tokens !== "") {
            phrase = expandDataTypeRegex(tokens, phrase);
        }
    }

    return phrase;  // return expanded phrase regex
}

// -----------------------------------------------------------------------------
// style editbox

// simplify struct/union definitions and function pointers
function sanitizeCurrentText() {

    // find structure and union definitions
    for (let match = compositeRegex.exec(text);
             match !== null;
             match = compositeRegex.exec(text)) {

        // extract definition and remove semicolons
        const start      = compositeRegex.lastIndex;
        const stop       = findCloser(start, "{", "}") - 1;
        const definition = text
            .substring(start, stop)
            .replace(/;/g, " ");

        // replace definition in text with cleaned copy
        text = text.substring(0, start) +  // text before match
               definition               +  // cleaned copy
               text.substring(stop);       // text after match
    }

    // find function pointers
    for (let match = callbackRegex.exec(text);
             match !== null;
             match = callbackRegex.exec(text)) {

        // get length of prefix and indices for identifier token
        const prefix = match[0].indexOf(match[1]);
        const start  = match.index + prefix;     // beginning of token
        const stop   = start + match[1].length;  // end of token

        // check if match is valid function pointer
        if (canStyle(start, stop) === false) {

            // if not valid, resume search at end of token
            callbackRegex.lastIndex = stop;
            continue;
        }

        // find parenthesis at end of function pointer declaration
        const closer = findCloser(callbackRegex.lastIndex, "(", ")");

        // replace function pointer prefix and suffix with spaces
        // keep identifier token, and all text before/after pointer
        text = text.substring(0, match.index) +  // text before match
               " ".repeat(prefix)             +  // replace prefix
               match[1]                       +  // keep token
               " ".repeat(closer - stop)      +  // replace suffix
               text.substring(closer);           // text after match
    }
}

// style function names and identifiers with local scope
function styleLocalScopes() {

    const functions    = [];             // collect function names
    let   stop         = 0;              // track end of previous scope
    let   currentTypes = dataTypeRegex;  // track added global typedefs

    // find beginning of next local scope
    for (let match = localScopeRegex.exec(text);
             match !== null;
             match = localScopeRegex.exec(text)) {

        // check if match is valid function
        if (addGroup("function", match) === false) {

            // if not valid, resume search at end of invalid token
            localScopeRegex.lastIndex = match.index + match[1].length;
            continue;
        }
        functions.push(match[1]);  // add function name to list

        // find global typedefs between previous and current scopes
        scope.set(stop, match.index);
        currentTypes = styleIdentifiers(
            "",             // parameter ignored by findTypedefs()
            findTypedefs,
            currentTypes,
            variableRegex,  // typedefs look like variable declarations
            true);          // expand data type regex and return result

        // move scope to function's body
        stop = findCloser(localScopeRegex.lastIndex, "{", "}");
        scope.set(localScopeRegex.lastIndex, stop - 1);

        // style parameters and local enumerations
        styleTokens("parameter", match, parameterRegex);
        styleIdentifiers("enumConstant",
            styleTokens, enumRegex, enumConstantRegex);

        // style local variables and local typedefs
        // current types expanded temporarily until end of current scope
        styleIdentifiers([ "localVariable", "typedef" ],
            styleVariables, currentTypes, variableRegex, true);

        // resume search at end of local scope
        localScopeRegex.lastIndex = stop;
    }

    // style function names - both known and probable
    quickStyle( "function", functions.join("|"));
    styleGroups("function", addFunction, functionRegex);

    scope.clear();
}

// update styling for text currently entered in typing area
function styleEditbox() {

    // get current text, remove styling, and normalize tag structure
    const editbox  = document.getElementById("editbox");
    const unstyled = initializeGlobals(editbox.innerHTML);

    // style comments and hide from future searches
    styleMatches("comment", hideMatch, commentRegex);

    // style string and numeric literals
    styleMatches("literal", splitMatch, stringRegex);
    styleGroups( "literal", addGroup,   includeFileRegex);
    styleMatches("literal", addMatch,   numberRegex);

    // style preprocessor directives, including macros
    styleMatches("preprocessor", addMatch, preprocessorRegex);
    styleGroups( "macro",        addMacro, macroRegex);

    // style keywords and tag types
    styleMatches("keyword", addMatch, keywordRegex);
    styleGroups( "tagType", addGroup, tagTypeRegex);

    // style local identifiers and function names
    sanitizeCurrentText();  // simplify certain things first
    styleLocalScopes();

    // style global enumerations
    styleIdentifiers("enumConstant",
        styleTokens, enumRegex, enumConstantRegex);

    // style global variables and global typedefs
    styleIdentifiers([ "globalVariable", "typedef" ],
        styleVariables, dataTypeRegex, variableRegex, true);

    // replace previous text with newly styled text
    // maintainCaret() defined in next section below
    maintainCaret(editbox, applyStyles(unstyled));
}

// -----------------------------------------------------------------------------
// manage caret position

// get length of node in characters, accounting for linebreaks
function nodeLength(node) {

    let length = node.textContent.length;

    // linebreaks add 1 extra character
    if (node.nodeName             === "DIV" || (
        node.nextSibling          !== null  &&
        node.nextSibling.nodeName === "DIV" )) {

        length++;
    }

    return length;
}

// convert selection range into character offset
function offsetFromRange(editbox, range) {

    let node   = range.endContainer;
    let offset = range.endOffset;

    if (node === editbox || editbox.contains(node) === false) {
        return 0;  // selection was outside editbox
    }

    // step backward through node hierarchy to find total offset
    else while (node !== editbox) {

        // step backward through siblings
        while (node.previousSibling !== null) {
            node    = node.previousSibling;
            offset += nodeLength(node);
        }

        // go up 1 level when no more siblings
        node = node.parentNode;
    }

    // return total offset from beginning of editbox
    return offset;
}

// -------------------------------------

// return selection range for target location
function buildRange(node, offset) {

    // check if offset out of bounds
    if (offset > node.textContent.length) {
        offset = node.textContent.length;
    }

    const range = document.createRange();
    range.setEnd(node, offset);
    range.collapse();  // collapse to end point set above

    return range;
}

// convert character offset into selection range
function rangeFromOffset(editbox, offset) {

    let node = editbox.firstChild;
    if (node === null) {
        return buildRange(editbox, 0);  // editbox was empty
    }

    // step forward through node hierarchy by total offset amount
    while (true) {

        const length = nodeLength(node);
        if (offset >= length) {  // is offset past current node?

            // should never happen, but just in case
            if (node.nextSibling === null) {
                break;
            }

            node    = node.nextSibling;
            offset -= length;  // track offset remaining

        } else {  // offset is within current node

            if (node.firstChild === null) {
                break;  // already at bottom of hierarchy
            }

            // go down 1 level for more fine-grain control
            node = node.firstChild;
        }
    }

    // ensure we are at bottom of node hierarchy
    while (node.firstChild !== null) {
        node = node.firstChild;
    }

    // create Range object representing current position
    return buildRange(node, offset);
}

// -------------------------------------

// remember caret location and restore after updating text
function maintainCaret(editbox, html) {

    // check if caret is active
    const selection = window.getSelection();
    if (selection            === null   ||
        selection.type       === "None" ||
        selection.rangeCount === 0) {

        editbox.innerHTML = html;  // caret not active
        return;
    }

    // save caret position, then update editbox text
    const offset = offsetFromRange(editbox, selection.getRangeAt(0));
    editbox.innerHTML = html;

    // restore caret position from offset
    selection.removeAllRanges();
    selection.addRange(rangeFromOffset(editbox, offset));
}

// -------------------------------------

// convert caret position to line/column numbers and display
function buildCaretString(editbox) {

    // check if caret is active
    const selection = window.getSelection();
    if (selection            === null   ||
        selection.type       === "None" ||
        selection.rangeCount === 0) {

        return "&nbsp;";  // no position to report
    }

    // check if caret inside editbox
    const range = selection.getRangeAt(0);
    if (editbox.contains(range.endContainer) === false) {

        return "&nbsp;";  // no position to report
    }

    // step forward through node hierarchy counting lines/columns
    let line   = 1;
    let column = 1;
    let node   = editbox.firstChild;
    while (node !== null) {

        // account for previous node not inside <div> tags
        if (node.nodeName                 === "DIV" &&
            node.previousSibling          !== null  &&
            node.previousSibling.nodeName !== "DIV") {

            line++;
            column = 1;  // must reset column number
        }

        // is caret inside current node?
        if (node === range.endContainer) {

            return "Ln "    +  line   +
                   ", Col " + (column + range.endOffset);

        // is caret after current node?
        } else if (node.contains(range.endContainer) === false) {

            if (node.nextSibling === null) {
                break;  // should never happen, but just in case
            }

            if (node.nodeName === "DIV") {  // handle <div> nodes
                line++;
                column = 1;
            } else {         // sum up length of other node types
                column += nodeLength(node);
            }

            node = node.nextSibling;  // step forward

        // caret must be inside nested child
        } else {

            if (node.firstChild === null) {
                break;  // should never happen, but just in case
            }

            // go down 1 level for more fine-grain control
            node = node.firstChild;
        }
    }

    // return default value on error or empty typing area
    return "Ln 1, Col 1";
}

// -----------------------------------------------------------------------------
// event handlers

let hasChanges = false;  // dirty flag for typing area

// EVENT LISTENER: triggered by
//     clicking on typing area or pressing arrow keys
function updateCaretPosition(event = null) {

    // for key down events, check which key was pressed
    if (event !== null && "key" in event === true) {
        switch (event.key) {

            case "ArrowUp":
            case "ArrowDown":
            case "ArrowLeft":
            case "ArrowRight":
                break;   // need to update displayed position

            default:
                return;  // nothing else should affect caret
        }
    }

    // calculate and show line/column numbers on toolbar
    document.getElementById("caretPosition").innerHTML =
        buildCaretString(document.getElementById("editbox"));
}

let updateTimer;  // debouncing timer

// EVENT LISTENER: triggered by user typing
function updateEditbox() {

    hasChanges = true;      // set dirty flag
    updateCaretPosition();  // update caret position text

    // after no typing for 2 seconds, update styling
    clearTimeout(updateTimer);
    updateTimer = setTimeout(styleEditbox, 2000);
}

// ask user if they want to save changes
function dropChanges() {

    return !hasChanges ||
           confirm("You will lose any unsaved changes.");
}

// BUTTON ACTION: delete contents of typing area
function clearEditbox() {

    if (dropChanges() === false) {
        return;
    }

    // reset page controls to default values
    document.getElementById("editbox").innerHTML = "";
    document.getElementById("filename").value    = "NewFile.txt";
    hasChanges                                   = false;

    updateCaretPosition();  // update caret position text
}

// -------------------------------------

// BUTTON ACTION: open file picker dialog box
function selectFile() {

    if (dropChanges() === false) {
        return;
    }

    const filePicker = document.getElementById("filePicker");

    // simulate user clicking on hidden file picker control
    filePicker.disabled = false;
    filePicker.click();
    filePicker.disabled = true;
}

// load file data into Context object with matching filename
function saveContext(filename, fileData) {

    const context    = getContext(filename);
    context.fileData = fileData;
}

// load file data into main typing area and update filename textbox
function displayFile(filename, fileData) {

    // update filename control
    if (filename.indexOf(".") === -1) {
        filename += ".";  // denotes no file extension
    }
    document.getElementById("filename").value = filename;

    // load file data into typing area and clear dirty flag
    document.getElementById("editbox").innerHTML = fileData;
    hasChanges                                   = false;

    styleEditbox();         // style newly loaded text
    updateCaretPosition();  // update caret position text
}

// handler function to finish loading file
let afterUpload = displayFile;

// EVENT LISTENER: triggered by closing file picker dialog box
// "this" is file picker control to which listener is attached
function uploadFile() {

    // check if user cancelled file picker
    if (this.files.length === 0) {
        return;
    }

    const filePicker = this;  // save for closure below

    // create and initialize file reader object
    const fileReader = new FileReader();
    fileReader.addEventListener("load", function() {

        // sanitize file data and convert newline characters
        let fileData = fileReader.result
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(newlineRegex, "</div><div>");

        // add opening/closing <div> tags and insert <br> tags
        fileData = "<div>" + fileData + "</div>";
        fileData = fileData.replace(emptyLineRegex, "<div><br></div>");

        // pass filename and file data to afterUpload() handler
        afterUpload(filePicker.files[0].name, fileData);
        filePicker.value = "";  // reset file picker control for reuse
    });

    // read selected file, triggering load listener defined above
    fileReader.readAsText(this.files[0]);
}

// -------------------------------------

// BUTTON ACTION: save contents of typing area to "Downloads" folder
function downloadFile() {

    let fileType      = "text/plain";
    let filenameParts = document.getElementById("filename").value
        .replace(filenameRegex, "_")  // remove invalid symbols
        .trim()
        .split(".");  // split actual filename from extension

    // determine filename
    let filename = filenameParts[0];
    if (filename === "") {
        filename = "NewFile";  // use default filename
    }

    // determine extension
    if (filenameParts.length === 1) {
        filename += ".txt";    // use default extension
    }
    else if (filenameParts[1] !== "") {
        filename += "." + filenameParts[1];  // keep extension
    }
    else {
        // original filename ended with period, so no extension
        // switch to file type with no default extension
        fileType = "application/octet-stream";
    }

    // convert HTML to plain text - many HTML tags are just discarded
    const fileData = document.getElementById("editbox").innerHTML
        .replace(stylingRegex,    "")
        .replace(/<\/div><div>/g, "\n")  // convert normal newlines
        .replace(/^<div>/,        "")    // remove opening <div>
        .replace(/<\/div>$/,      "")    // remove closing </div>
        .replace(/<br>/g,         "")
        .replace(/<\/?div>/g,     "\n")  // convert abnormal newlines
        .replace(/&lt;/g,         "<")
        .replace(/&gt;/g,         ">");

    // create temporary download link
    const file    = new Blob([ fileData ], { type: fileType });
    const url     = URL.createObjectURL(file);
    const link    = document.createElement("a");
    link.href     = url;
    link.download = filename;

    // simulate user clicking temporary download link, then clean up
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);  // free up resources

    hasChanges = false;  // clear dirty flag
}

// -------------------------------------

// EVENT LISTENER: triggered by user trying to leave page
function exitPage(event) {

    if (hasChanges === true) {

        if (typeof event.preventDefault === "function") {
            event.preventDefault();         // for newer browsers
        } else {
            event.returnValue = "confirm";  // for older browsers
        }
    }
}

// attach event listeners and prepare page for user
function initializePage() {

    window.addEventListener("beforeunload", exitPage);

    document.getElementById("filePicker")
        .addEventListener("change", uploadFile);

    const editbox = document.getElementById("editbox");
    editbox.addEventListener("input", updateEditbox);
    editbox.addEventListener("click", updateCaretPosition);
    editbox.addEventListener("keyup", updateCaretPosition);

    clearEditbox();  // same as clicking "New File" button
}

// -----------------------------------------------------------------------------
    </script>

</head>
<body onload="initializePage()">
<div id="container">

    <div id="toolbar">

        <!-- hidden behind other controls -->
        <input type="file"
               id="filePicker"
               accept="text/plain"
               disabled><!-- enabled only when needed -->

        <input type="button"
               value="New File"
               onclick="clearEditbox()">

        <!-- triggers above file picker control -->
        <input type="button"
               value="Open File"
               onclick="selectFile()">

        <input type="button"
               value="Save to Downloads"
               onclick="downloadFile()">

        <div id="currentFile">
            <label for="filename">Current File:</label>
            <input id="filename" type="text">
        </div>

        <div id="caretPosition"></div>

    </div><!-- end of toolbar -->

    <div id="editbox"
         contenteditable="true"
         spellcheck="false"></div>

</div><!-- end of container -->
</body>
</html>
