<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Keyword Highlighter</title>

    <style>
/* -------------------------------------------------------------------------- */

body, input {
    font-family: "Courier New", Courier, monospace;
}

#viewPort {
    display:        flex;
    flex-direction: column;
    width:          85vw;
    height:         85vh;
    margin:         1.5em auto 0;
    padding:        0;
}

#editBox {
    flex-grow:   1;
    white-space: preserve nowrap;
    overflow:    auto;
    border:      0.1em solid black;
    outline:     none;
    margin:      0;
    padding:     0.6em 0.8em;
}

#toolBar {
    flex-grow: 0;
    margin:    0;
    padding:   0 0 0.7em;
}

#filePicker {
    position: absolute;
    z-index:  -1;
    opacity:  0;
}

#fileName {
    width: 40em;
}

.keyword {
    color: blue;
}

.literal {
    color: red;
}

.comment {
    color: green;
}

/* -------------------------------------------------------------------------- */
    </style>
    <script>
// -----------------------------------------------------------------------------

class InputToken {

    constructor(text, index, style = "") {
        this.text  = text;
        this.index = index;
        this.style = style;
    }

    getEnd() {
        return this.index + this.text.length;
    }

    contains(text) {
        return this.text.indexOf(text) > -1;
    }
}

function tokenizeInput(input) {

    const tokens    = [];
    const rawTokens = input.split(/\W+/).filter((s) => s.length > 0);

    for (let index=0, token=0; token < rawTokens.length; token++) {

        index                 = input.indexOf(rawTokens[token], index);
        tokens[tokens.length] = new InputToken(rawTokens[token], index);

        index += rawTokens[token].length;
    }

    return tokens;
}

function styleRanges(input, startText, endText, tokens, style) {

    for (let endIndex,
             startIndex = input.indexOf(startText);
             startIndex > -1;
             startIndex = input.indexOf(startText, endIndex)) {

        endIndex = input.indexOf(endText, startIndex + startText.length);
        if (endIndex > -1) {
            endIndex += endText.length;
        } else {
            endIndex  = input.length;
        }

        const text  = input.substring(startIndex, endIndex);
        const token = new InputToken(text, startIndex, style);

        let tokenStart = tokens.length > 0  ?  -1 : 0;
        let tokenCount = 0;
        for (let index = 0; index < tokens.length; index++) {

            if (tokens[index].index < startIndex) {
                continue;
            }

            if (tokenStart < 0) {
                if (index > 0 && tokens[index - 1].contains(startText)) {
                    break;
                }
                tokenStart = index;
            }

            if (tokens[index].index >= endIndex) {
                break;
            }

            tokenCount++;
        }

        if (tokenStart > -1) {
            tokens.splice(tokenStart, tokenCount, token);
        }
    }
}

function styleTokens(wordList, tokens, style) {

    for (let index = 0; index < tokens.length; index++) {
        for (let word = 0; word < wordList.length; word++) {

            if (tokens[index].text == wordList[word]) {
                tokens[index].style = style;
            }
        }
    }
}

function buildStyledHTML(input, tokens) {

    const validTokens = tokens.filter((t) => t.style != "");
    if (validTokens.length < 1) {
        return input;
    }

    let html = input.substring(0, validTokens[0].index);
    for (let index = 0; index < validTokens.length; index++) {

        html += "<span class='" + validTokens[index].style + "'>";
        html += validTokens[index].text;
        html += "</span>";

        if (index + 1 >= validTokens.length) {
            html += input.substring(validTokens[index].getEnd());
        } else {
            html += input.substring(validTokens[index].getEnd(),
                                    validTokens[index + 1].index);
        }
    }

    return html;
}

// -----------------------------------------------------------------------------

const keywordList = [
    "_Alignas",
    "_Alignof",
    "_Atomic",
    "_BitInt",
    "_Bool",
    "_Complex",
    "_Decimal128",
    "_Decimal32",
    "_Decimal64",
    "_Generic",
    "_Imaginary",
    "_Noreturn",
    "_Static_assert",
    "_Thread_local",
    "alignas",
    "alignof",
    "asm",
    "atomic_bool",
    "atomic_char",
    "atomic_char16_t",
    "atomic_char32_t",
    "atomic_char8_t",
    "atomic_int",
    "atomic_int_fast16_t",
    "atomic_int_fast32_t",
    "atomic_int_fast64_t",
    "atomic_int_fast8_t",
    "atomic_int_least16_t",
    "atomic_int_least32_t",
    "atomic_int_least64_t",
    "atomic_int_least8_t",
    "atomic_intmax_t",
    "atomic_intptr_t",
    "atomic_llong",
    "atomic_long",
    "atomic_ptrdiff_t",
    "atomic_schar",
    "atomic_short",
    "atomic_size_t",
    "atomic_uchar",
    "atomic_uint",
    "atomic_uint_fast16_t",
    "atomic_uint_fast32_t",
    "atomic_uint_fast64_t",
    "atomic_uint_fast8_t",
    "atomic_uint_least16_t",
    "atomic_uint_least32_t",
    "atomic_uint_least64_t",
    "atomic_uint_least8_t",
    "atomic_uintmax_t",
    "atomic_uintptr_t",
    "atomic_ullong",
    "atomic_ulong",
    "atomic_ushort",
    "atomic_wchar_t",
    "auto",
    "bool",
    "break",
    "case",
    "char",
    "char16_t",
    "char32_t",
    "char8_t",
    "complex",
    "const",
    "constexpr",
    "continue",
    "default",
    "do",
    "double",
    "else",
    "enum",
    "extern",
    "false",
    "float",
    "for",
    "fortran",
    "goto",
    "if",
    "imaginary",
    "inline",
    "int",
    "int_fast16_t",
    "int_fast32_t",
    "int_fast64_t",
    "int_fast8_t",
    "int_least16_t",
    "int_least32_t",
    "int_least64_t",
    "int_least8_t",
    "intmax_t",
    "intptr_t",
    "long",
    "noreturn",
    "nullptr",
    "ptrdiff_t",
    "register",
    "restrict",
    "return",
    "short",
    "signed",
    "size_t",
    "sizeof",
    "static",
    "static_assert",
    "struct",
    "switch",
    "thread_local",
    "true",
    "typedef",
    "typeof",
    "typeof_unqual",
    "uint_fast16_t",
    "uint_fast32_t",
    "uint_fast64_t",
    "uint_fast8_t",
    "uint_least16_t",
    "uint_least32_t",
    "uint_least64_t",
    "uint_least8_t",
    "uintmax_t",
    "uintptr_t",
    "union",
    "unsigned",
    "void",
    "volatile",
    "wchar_t",
    "while"
];

function getUnstyledHTML(element) {

    let html = element.innerHTML;
        html = html.replace(/<span[^>]*>/g, "");
        html = html.replace(/<font[^>]*>/g, "");
        html = html.replace(/<\/span>/g, "");
        html = html.replace(/<\/font>/g, "");

    return html;
}

function saveCaret(element, html) {

    const selection = window.getSelection();
    if (selection && selection.rangeCount < 1) {
        element.innerHTML = html;
        return;
    }

    const range = selection.getRangeAt(0).cloneRange();
    range.setStart(element, 0);
    let caret = range.toString().length;

    element.innerHTML = html;

    const tree = document.createTreeWalker(element, NodeFilter.SHOW_TEXT);
    while (tree.nextNode() != null && caret > tree.currentNode.length) {
        caret -= tree.currentNode.length;
    }
    caret = Math.min(caret, tree.currentNode.length);

    range.setStart(tree.currentNode, caret);
    range.collapse(true);
    selection.removeAllRanges();
    selection.addRange(range);
}

function styleEditBox() {

    const editBox = document.getElementById("editBox");
    const html    = getUnstyledHTML(editBox);
    const tokens  = tokenizeInput(html);

    styleRanges(html, "\"", "\"", tokens, "literal");
    styleRanges(html, "/*", "*/", tokens, "comment");
    styleTokens(keywordList, tokens, "keyword");

    saveCaret(editBox, buildStyledHTML(html, tokens));
}

let stylingTimer;
function debounceStyling() {

    clearTimeout(stylingTimer);
    stylingTimer = setTimeout(styleEditBox, 2000);
}

// -----------------------------------------------------------------------------

function pickFile() {
    document.getElementById("filePicker").click();
}

function loadFile(content) {

    content = content.replace(/</g, "&lt;").replace(/>/g, "&gt;");

    const editBox = document.getElementById("editBox");
    const lines   = content.split(/(?:\r*\n|\r)/);

    if (lines.length < 2) {
        editBox.innerHTML = lines[0];
    } else {

        let html = "";
        for (let index = 0; index < lines.length; index++) {

            if (lines[index].length < 1) {
                lines[index] = "<br>";
            }
            html += "<div>" + lines[index] + "</div>";
        }

        editBox.innerHTML = html;
    }

    styleEditBox();
}

function readFile() {

    if (this.files.length > 0) {

        document.getElementById("fileName").value = this.files[0].name;

        const reader = new FileReader();
        reader.addEventListener("load", function () {
            loadFile(reader.result);
        });

        reader.readAsText(this.files[0]);
        this.value = "";
    }
}

function downloadFile() {

    let content = getUnstyledHTML(document.getElementById("editBox"));
        content = content.replace(/<div[^>]*>/g, "\n");
        content = content.replace(/<\/div>/g,    "");
        content = content.replace(/<br>/g,       "");

    if (content[0] == "\n") {
        content = content.substring(1);
    }

    const url = URL.createObjectURL(new Blob(
        [content],
        { type: "text/plain" }
    ));

    const link          = document.createElement("a");
          link.href     = url;
          link.download = document.getElementById("fileName").value;

    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    URL.revokeObjectURL(url);
}

// -----------------------------------------------------------------------------

function onPageLoad() {

    document
        .getElementById("filePicker")
        .addEventListener("change", readFile);

    document
        .getElementById("editBox")
        .addEventListener("input", debounceStyling);
}

// -----------------------------------------------------------------------------
    </script>

</head>
<body onload="onPageLoad()">

    <div id="viewPort">
        <div id="toolBar">

            <input type="file"
                   id="filePicker"
                   accept="text/plain">

            <input type="button"
                   value="Open File"
                   onclick="pickFile()">

            <input type="button"
                   value="Save to Downloads"
                   onclick="downloadFile()">

            <label for="fileName">Current File:</label>
            <input type="text" id="fileName" value="temp.txt">

        </div>
        <div id="editBox" contenteditable="true" spellcheck="false"></div>
    </div>

</body>
</html>
