<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme"
          content="light dark"><!-- supports dark mode -->

    <title>Keyword Highlighter</title>

    <style>
/* -------------------------------------------------------------------------- */

body, input {
    font-family: "Courier New", Courier, monospace;
    font-size:   12pt;
}

/* top-level flexbox */
#layout {
    display:        flex;
    flex-direction: column;      /* toolbar over editbox */
    width:          85vw;
    height:         90vh;
    margin:         1.4em auto;  /* center horizontally */
}

/* shows caret position at bottom of page */
#caretPosition {
    flex-grow: 0;
    padding:   0.1em 0 1.1em 0.3em;
}

/* ---------------------------------- */

/* container for interface controls */
#toolbar {
    flex-grow: 0;         /* minimize footprint */
    position:  relative;  /* needed to position file picker */
}

/* hidden behind other controls */
/* also starts disabled (see HTML at end of file) */
#filePicker {
    position: absolute;
    z-index:  -1;
    opacity:  0;  /* also invisible */
}

/* size filename textbox */
#filename {
    width:   40em;
    outline: none;
}

/* add space between interface controls when arranged vertically */
input {
    margin: 0.2em 0;
}

/* ---------------------------------- */

/* second-level flexbox for typing area and notifications */
#container {
    flex-grow:      1;            /* fill most of top-level flexbox */
    display:        flex;
    flex-direction: column;
    margin:         0.6em 0 0;    /* add space below toolbar */
    border:         0.1em solid;  /* border color set later */
    z-index:        2;            /* on top of notification messages */
    position:       relative;     /* needed to position notifications */
    overflow:       hidden;       /* clip notifications to container */
}

/* typing area */
#editbox {
    flex-grow:   1;            /* entirely fill second-level flexbox */
    padding:     0.6em 0.8em;
    white-space: preserve nowrap;
    overflow:    auto;         /* add scrollbars if/when needed */
    outline:     none;
}

/* missing context message */
.notification {
    position: absolute;
    z-index:  1;             /* on top of editbox */
    top:      0.7em;         /* in upper right corner */
    right:    1.2em;
    padding:  1em 2em 0;
    border:   0.05em solid;  /* border color set later */
}

/* indent text */
.indent {
    margin:  0 0 0 2em;
}

/* general positioning */
.floatLeft  { float: left;  }
.floatRight { float: right; }

/* -------------------------------------------------------------------------- */
/* colors for page elements and highlighted text */

/* for light mode */
#editbox {
    color:            black;
    background-color: #F9F9F9;  /* off white */
    border-color:     black;
}

/* for dark mode */
@media(prefers-color-scheme: dark) {
#editbox {
    color:            white;
    background-color: silver;
    border-color:     #6B6B6B;  /* gray */
} }

/* notifications are always the same colors */
.notification {
    color:            black;
    background-color: #FFBBBB;  /* pink */
    border-color:     black;
}

/* text highlight colors */
.keyword        { color: #1010FF; }  /* blue   */
.literal        { color: #D00000; }  /* red    */
.localVariable  { color: #E717E7; }  /* pink   */
.globalVariable { color: #E76700; }  /* orange */
.tagType        { color: #009797; }  /* teal   */
.enumConstant   { color: #9000C0; }  /* purple */
.typedef        { color: #009797; }  /* teal   */
.function       { color: #E76700; }  /* orange */
.parameter      { color: #6B6B6B; }  /* gray   */
.preprocessor   { color: #6B6B6B; }  /* gray   */
.macro          { color: #9000C0; }  /* purple */
.comment        { color: #009000; }  /* green  */

/* -------------------------------------------------------------------------- */
    </style>
    <script>
// -----------------------------------------------------------------------------
// keyword lists

const preprocessorDirectives = [
    "define",
    "undef",
    "if",
    "ifdef",
    "ifndef",
    "else",
    "elif",
    "elifdef",
    "elifndef",
    "endif",
    "include",
    "embed",
    "warning",
    "error",
    "line",
    "pragma"
];

const dataTypes = [
    "int",
    "short",
    "long",
    "signed",
    "unsigned",
    "float",
    "double",
    "char",
    "wchar_t",
    "bool",
    "void",
    "struct",
    "union",
    "enum",
    "typedef"
];

const otherKeywords = [
    "auto",
    "const",
    "static",
    "extern",
    "register",
    "volatile",
    "if",
    "else",
    "switch",
    "case",
    "default",
    "break",
    "do",
    "while",
    "for",
    "continue",
    "sizeof",
    "goto",
    "return"
];

// -----------------------------------------------------------------------------
// regular expressions

const newline   = "</div><div>";
const emptyLine = "<div><br></div>";

const emptyLineRegex = /<div><\/div>/g;   // lines missing <br> tag
const linebreakRegex = /<\/?div>|<br>/;   // global flag not needed
const newlineRegex   = /\r*\n|\r/g;       // most line ending combos
const filenameRegex  = /[\\\/:*?"<>|]/g;  // common invalid symbols

// some browsers insert <font> tags during editing
const stylingRegex = /<\/?span[^>]*>|<\/?font[^>]*>/g;

// matches both single and multi-line comments
const commentRegex = /\/\/.*?(?:<\/?div>|$)|\/\*.*?\*\//g;
const numberRegex  = /(?<![A-Za-z_])-?\.?\b\d[A-Za-z\d.-]*/g;

// matches both character and string literals
// also allows for line continuation
const stringRegex =
    /(?:L|U|u|u8)?(['"]).*?(?<!\\<\/div>|.{6}\\)(?:\1|<div>)/g;

// match either type of include files
const systemFileRegex  = /#\s*include\s+(&lt;.*?(?:&gt;|<\/?div>))/g;
const projectFileRegex = /#\s*include\s+(".*?(?:"|<\/?div>))/g;

const macroRegex        = /#\s*define\s+([A-Za-z_]\w*)/g;
const preprocessorRegex = new RegExp(
    "#\\s*(?:" + preprocessorDirectives.join("|") + ")\\b", "g");

const keywordRegex = new RegExp(
    "\\b(?:" + dataTypes.join("|") + "|" +
           otherKeywords.join("|") + ")\\b", "g");

// both of these match entire statement from data type to semicolon
const enumRegex     = /\benum\b[^;]*;/g;
const dataTypeRegex = new RegExp(
    "\\b(?:" + dataTypes.join("|") + ")\\b[^;]*;", "g");

// update data type regex to include newly found typedefs
function expandDataTypeRegex(typedefs, previous) {

    const begin = "\\b(?:";
    const end   = ")\\b[^;]*;";

    // combine previously found data types with new typedefs
    const combined = previous.source
        .replace(begin, "")
        .replace(end,   "") + "|" + typedefs.join("|");

    const regex     = new RegExp(begin + combined + end, "g");
    regex.lastIndex = previous.lastIndex;  // carry over last index

    return regex;
}

// -------------------------------------

// create regex from multiple patterns with whitespace in between
function createPatternRegex(patterns) {

    // might have whitespace, or patterns might run together
    const whitespace = "(?:\\s|</?div>|<br>)*";

    let sequence = "";
    for (let i = 0; i < patterns.length - 1; i++) {
        sequence += patterns[i] + whitespace;
    }

    // add final pattern to end and return as global regex
    return new RegExp(sequence + patterns[patterns.length - 1], "g");
}

// pattern for capturing identifier tokens
const identifierToken = "(\\b[A-Za-z_]\\w*)";

// PATTERN: enum/struct/union followed by identifier
const tagTypeRegex = createPatternRegex(
    [ "\\b(?:enum|struct|union)", identifierToken ]);

// PATTERN: struct/union followed by optional identifer and open brace
const compositeRegex = createPatternRegex(
    [ "\\b(?:struct|union)", identifierToken + "?", "\\{" ]);

// PATTERN: optional identifier followed by one of: {[=&,;
// semicolon terminates declaration
// ampersand needed to avoid matching HTML entities
const variableRegex = createPatternRegex(
    [ identifierToken + "?", "([{[=&,;])" ]);

// PATTERN: optional identifier followed by one of: [,)
// closed parenthesis terminates declaration
const parameterRegex = createPatternRegex(
    [ identifierToken + "?", "([[,)])" ]);

// PATTERN: optional identifier followed by one of: =,}
// closed brace terminates declaration
const enumConstantRegex = createPatternRegex(
    [ identifierToken + "?", "([=,}])" ]);

// PATTERN: identifier followed by open parenthesis
const functionRegex = createPatternRegex(
    [ identifierToken, "\\(" ]);

// PATTERN: identifier followed by text in parentheses and open brace
const localScopeRegex = createPatternRegex(
    [ identifierToken, "\\([^)]*\\)", "\\{" ]);

// PATTERN: open parenthesis followed by asterisk, identifier,
//              closed parenthesis, and second open parenthesis
const callbackRegex = createPatternRegex(
    [ "\\([^*)]*\\*", identifierToken, "\\)", "\\(" ]);

// -----------------------------------------------------------------------------
// global data management

// current text to be styled
// modified at various points to simplify regex matching
let text = "";

// one specific region of current text
// stop index goes one past end of string
class Scope {

    constructor(start = 0, stop = 0) {
        this.start = start;
        this.stop  = stop;  // first index outside of scope
    }

    set(start, stop) {
        this.start = start;
        this.stop  = stop;
    }

    // target entirety of current text
    clear() {
        this.start = 0;
        this.stop  = text.length;
    }
}

// region of current text to apply given style
class Style extends Scope {

    constructor(style, start, stop) {
        super(start, stop);
        this.style = style;  // used in <span> tag
    }
}

// contents of separate file to also scan during styling
// used to load header files and import macros, typedefs, etc.
class Context {

    constructor(filename) {
        this.filename     = filename;
        this.fileData     = "";    // always loaded after creation
        this.systemFile   = false;
        this.notification = null;  // reference to popup message
    }

    getFilename() {

        let filename = this.filename;
        if (this.systemFile === true) {
            filename = "&lt;" + filename + "&gt;";
        } else {
            filename = "\"" + filename + "\"";
        }

        return filename;
    }
}

const contexts = [];           // array of Context objects
const styles   = [];           // array of Style objects
const local    = new Scope();  // indices of current local scope
const search   = new Scope();  // indices of current search scope

// -------------------------------------

// total length of context files prepended to text
let allowance = 0;

// prepare for next styling pass
function initializeGlobals(html) {

    // remove styling and normalize tag structure
    const unstyled = html
        .replace(stylingRegex,   "")
        .replace(newlineRegex,   newline)
        .replace(emptyLineRegex, emptyLine);

    // merge all context files together
    let context = "";
    for (let i = 0; i < contexts.length; i++) {

        // add empty line between files for safety
        context += contexts[i].fileData + emptyLine;
    }

    // combine context files and unstyled text
    text      = context + unstyled;
    allowance = context.length;  // remember total length of files

    // scan combined text for any #include files without context data
    // createNotifications() defined in "manage notifications" section
    createNotifications(text);

    // zero out other global variables
    styles.length = 0;  // discard previous Style objects
    local.clear();
    search.clear();

    return unstyled;  // needed by applyStyles()
}

// is region outside of any existing Style object?
function canStyle(start, stop) {

    // adjust indices by total length of context files
    start -= allowance;
    stop  -= allowance;

    for (let i = 0; i < styles.length; i++) {

        if (start < styles[i].stop && stop > styles[i].start) {
            return false;  // cannot style - regions would overlap
        }
    }

    return true;  // could style - no overlap
}

// create Style object from parameters and append to end of styles array
function addStyle(style, start, stop) {

    // adjust indices by total length of context files
    styles.push(new Style(style, start - allowance, stop - allowance));
}

// build finished text based on current Style objects
// needs text without modifications returned by initializeGlobals()
function applyStyles(unstyled) {

    styles.sort(function(a, b) {
        return a.start - b.start; });  // sort by starting index

    // remove any styles with indices before start of file
    // they were generated from context files and don't display
    while (styles.length > 0 && styles[0].start < 0) {

        styles.shift();  // drop first Style object from array
    }

    if (styles.length === 0) {
        return unstyled;  // no styles (left) to apply
    }

    // create shorter name for String.substring() calls
    const mid = unstyled.substring.bind(unstyled);

    let html = mid(0, styles[0].start);  // get text before first Style
    for (let i = 0; i < styles.length; i++) {

        // wrap target text with <span> tag
        html += "<span class='" + styles[i].style + "'>" +
                mid(styles[i].start, styles[i].stop)     +
                "</span>";

        // copy text between current Style object and next one
        if (i + 1 < styles.length) {
            html += mid(styles[i].stop, styles[i + 1].start);
        } else {
            html += mid(styles[i].stop);  // get text after last Style
        }
    }

    return html;
}

// -----------------------------------------------------------------------------
// style entire regex matches

// action functions are passed as arguments to filter functions
// filter functions execute regex and call action for each match found

// ACTION: add to styles array, but prevent overlapping regions
function addMatch(style, start, stop) {

    if (canStyle(start, stop) === false) {
        return false;  // cannot add - text already styled
    }

    addStyle(style, start, stop);
    return true;  // style added successfully
}

// ACTION: add to styles array, but also account for line breaks
function splitMatch(style, start, stop) {

    if (canStyle(start, stop) === false) {
        return false;  // cannot add - text already styled
    }

    // break regex match into lines
    const lines = text
        .substring(start, stop)
        .split(linebreakRegex)
        .filter(function(s) {
            return s.length > 0; });  // remove empty strings

    stop = start;  // needed for first iteration
    for (let i = 0; i < lines.length; i++) {

        // find current line in original text
        start = text.indexOf(lines[i], stop);
        stop  = start + lines[i].length;

        addStyle(style, start, stop);  // add styling
    }

    return true;  // style(s) added successfully
}

// ACTION: add to styles array, but also hide from future searches
function hideMatch(style, start, stop) {

    if (splitMatch(style, start, stop) === false) {
        return;  // cannot add - text already styled
    }

    // replace regex match with spaces
    text = text.substring(0, start) +  // text before match
           " ".repeat(stop - start) +  // same number of characters
           text.substring(stop);       // text after match
}

// FILTER: apply style using given action for each regex match
function styleMatches(style, action, regex) {

    regex.lastIndex = search.start;  // respect search scope

    for (let match = regex.exec(text);
             match !== null;
             match = regex.exec(text)) {

        const stop = match.index + match[0].length;
        if (stop > search.stop) {
            break;  // respect search scope
        }

        action(style, match.index, stop);
    }
}

// use temporary regex to apply style to each match
// "tokens" can be either single token or pre-joined string of tokens
function quickStyle(style, tokens) {

    // confirm valid token list provided
    if (tokens !== "") {

        const regex = new RegExp("\\b(?:" + tokens + ")\\b", "g");
        styleMatches(style, addMatch, regex);
    }
}

// -----------------------------------------------------------------------------
// only style first capture group

// ACTION: try to style first capture group and report success/failure
function addGroup(style, match) {

    // extract token from match and remove any stray linebreaks
    const token = match[1].replace(linebreakRegex, "");

    // find token within full text
    const start = match.index + match[0].indexOf(token);
    const stop  = start + token.length;

    return addMatch(style, start, stop);  // try to add style
}

// search for #undef declaration matching given token
function findUndef(token, start, style) {

    // build regex around provided token
    const regex = new RegExp("#\\s*undef\\s+(" + token + ")\\b", "g");

    regex.lastIndex = start;  // start at end of original #define

    for (let match = regex.exec(text);
             match !== null;
             match = regex.exec(text)) {

        // confirm matching #undef is outside comment/string/etc.
        if (addGroup(style, match) === true) {

            // matching #undef found!
            return match.index;
        }
    }

    return text.length;  // no matching #undef - use end of file
}

// ACTION: check potential macro and style within its valid scope
function addMacro(style, match) {

    // check if macro defined outside comment/string/etc.
    if (addGroup(style, match) === false) {
        return;  // macro not valid - text already styled
    }

    // limit next search to macro's valid scope
    // match[1] is capture group containing macro token
    const start = match.index + match[0].length;
    search.set(
        start,
        findUndef(match[1], start, style));

    // search for macro and apply style
    quickStyle(style, match[1]);
    search.clear();  // remove search limit set above
}

// ACTION: check potential function name and style if valid
function addFunction(style, match) {

    // check if function name outside comment/string/etc.
    if (addGroup(style, match) === false) {
        return;  // function name not valid - text already styled
    }

    // match[1] is capture group containing function name
    quickStyle(style, match[1]);
}

// FILTER: apply style using given action for each regex match
//     note that search scope is ignored by this filter
function styleGroups(style, action, regex) {

    for (let match = regex.exec(text);
             match !== null;
             match = regex.exec(text)) {

        action(style, match);
    }
}

// -----------------------------------------------------------------------------
// style identifier tokens

// find matching bracket/brace for symbol just before starting index
function findCloser(start, opener, closer) {

    start--;           // back up to original opener
    let stop = start;  // needed for first iteration
    do {

        // find next closing symbol
        stop = text.indexOf(closer, stop + closer.length);
        if (stop === -1) {
            stop = text.length - 1;  // nothing left to match
        }

        // find next opening symbol
        start = text.indexOf(opener, start + opener.length);
        if (start === -1) {
            start = text.length - 1;  // nothing left to match
        }

    // start is less than stop only when current opener is nested
    // if nested, current closer cannot match with original opener
    } while (start < stop);

    // return index after matching closer, or text.length if no match
    return stop + 1;
}

// add token to array if outside any existing Style object's region
function addToken(match, tokens) {

    // match[1] is identifier token
    if (match[1] !== undefined &&  // token may have been optional
        canStyle(
            match.index,
            match.index + match[1].length) === true) {

        tokens.push(match[1]);  // add to provided array
    }
}

// extract valid identifier tokens within current search region
function findTokens(regex) {

    // collect tokens in local array - returned when done
    const tokens = [];
    let   canAdd = true;  // add next token?

    regex.lastIndex = search.start;  // respect search scope

    for (let match = regex.exec(text);
             match !== null;
             match = regex.exec(text)) {

        const stop = match.index + match[0].length;
        if (stop > search.stop) {
            break;  // respect search scope
        }

        // switch on captured symbol character
        switch (match[2]) {  // match[2] is symbol after token

            // regex parameter limits which of these cases get used
            // if it's not captured by regex, it's ignored

            // skip any text inside braces
            case "{":
                regex.lastIndex = findCloser(regex.lastIndex, "{", "}");
                break;

            // add token in front of brackets
            // then skip any text inside brackets
            case "[":
                if (canAdd === true) {        // first match only
                    addToken(match, tokens);  // add identifier token
                    canAdd = false;
                }
                regex.lastIndex = findCloser(regex.lastIndex, "[", "]");
                break;

            // add token in front of equals sign
            case "=":
                if (canAdd === true) {        // first match only
                    addToken(match, tokens);  // add identifier token
                    canAdd = false;
                }
                break;

            // nothing after ampersand is valid token
            case "&":
                canAdd = false;  // disable matching
                break;

            // add token in front of comma
            case ",":
                if (canAdd === true) {        // first match only
                    addToken(match, tokens);  // add identifier token
                }
                canAdd = true;  // reset matching flag
                break;

            // add token in front of declaration terminator
            case ";":  // terminator for variables and typedefs
            case ")":  // terminator for parameters
            case "}":  // terminator for enumeration constants
                if (canAdd === true) {        // first match only
                    addToken(match, tokens);  // add identifier token
                }
                return tokens;  // declaration finished
        }
    }

    return tokens;  // no declaration terminator found
}

// -------------------------------------

// ACTION: extract typedefs from match - first parameter ignored
function findTypedefs(unused, match, regex) {

    // determine if match is actually typedef declaration
    if (match[0].indexOf("typedef") !== -1) {

        // extract list of typedefs
        search.set(match.index, match.index + match[0].length);
        const tokens = findTokens(regex);
        search.clear();

        return tokens;  // return new typedefs
    }

    return "";  // no typedefs to return
}

// ACTION: find identifier tokens and style within current scope
function styleTokens(style, match, regex) {

    // extract list of tokens
    search.set(match.index, match.index + match[0].length);
    const tokens = findTokens(regex);

    // apply style through end of current scope
    search.stop = local.stop;
    quickStyle(style, tokens.join("|"));
    search.clear();

    return tokens;  // needed for typedef handling
}

// ACTION: find variables and typedefs and style within current scope
//     note that style parameter is array of strings here
function styleVariables(style, match, regex) {

    // determine if match is typedef or variable declaration
    if (match[0].indexOf("typedef") !== -1) {

        // style typedefs and return identifier tokens
        return styleTokens(style[1], match, regex);

    } else {

        // style variables, then return empty string
        styleTokens(style[0], match, regex);
        return "";  // no typedefs to return
    }
}

// FILTER: apply style using given action to each matching phrase
//     expanding phrase regex needed for typedef handling
function styleIdentifiers(style, action, phrase, regex, expand = false) {

    phrase.lastIndex = local.start;  // respect current scope

    // locate match for phrase regex within current text
    for (let match = phrase.exec(text);
             match !== null;
             match = phrase.exec(text)) {

        const stop = match.index + match[0].length;
        if (stop > local.stop) {
            break;  // respect current scope
        }

        // apply action to matching phrase using second regex
        const tokens = action(style, match, regex);

        // optionally, also expand phrase regex with any typedefs found
        if (expand === true && tokens !== "") {
            phrase = expandDataTypeRegex(tokens, phrase);
        }
    }

    return phrase;  // return expanded phrase regex
}

// -----------------------------------------------------------------------------
// style editbox

// simplify struct/union definitions and function pointers
// prevents false matches and simplifies regex definitions
function sanitizeCurrentText() {

    // find structure and union definitions
    for (let match = compositeRegex.exec(text);
             match !== null;
             match = compositeRegex.exec(text)) {

        // extract definition and remove semicolons
        const start      = compositeRegex.lastIndex;
        const stop       = findCloser(start, "{", "}") - 1;
        const definition = text
            .substring(start, stop)
            .replace(/;/g, " ");

        // replace definition in text with cleaned copy
        text = text.substring(0, start) +  // text before match
               definition               +  // cleaned copy
               text.substring(stop);       // text after match
    }

    // ---------------------------------

    // find function pointers
    for (let match = callbackRegex.exec(text);
             match !== null;
             match = callbackRegex.exec(text)) {

        // get length of prefix and indices for function pointer name
        // match[1] is capture group containing pointer name
        const prefix = match[0].indexOf(match[1]);
        const start  = match.index + prefix;     // beginning of token
        const stop   = start + match[1].length;  // end of token

        // check if match is valid function pointer
        if (canStyle(start, stop) === false) {

            // if not valid, resume search at end of token
            callbackRegex.lastIndex = stop;
            continue;
        }

        // find parenthesis at end of function pointer declaration
        const closer = findCloser(callbackRegex.lastIndex, "(", ")");
        const suffix = closer - stop;

        // replace function pointer prefix and suffix with spaces
        // keep pointer name and text before/after it the same
        text = text.substring(0, match.index) +  // text before match
               " ".repeat(prefix)             +  // replace prefix
               match[1]                       +  // keep pointer name
               " ".repeat(suffix)             +  // replace suffix
               text.substring(closer);           // text after match
    }
}

// style function names and identifiers in all local scopes
function styleLocalScopes() {

    const functions    = [];             // collect function names
    let   stop         = 0;              // track end of previous scope
    let   currentTypes = dataTypeRegex;  // track global typedefs found

    // find beginning of next local scope
    for (let match = localScopeRegex.exec(text);
             match !== null;
             match = localScopeRegex.exec(text)) {

        // check if match is valid function
        if (addGroup("function", match) === false) {

            // if not valid, resume search at end of invalid token
            // match[1] is capture group containing function name
            localScopeRegex.lastIndex = match.index + match[1].length;
            continue;

        } else {
            functions.push(match[1]);  // add function name to list
        }

        // find global typedefs between previous and current scopes
        local.set(stop, match.index);
        currentTypes = styleIdentifiers(
            "",             // ignored by findTypedefs() anyway
            findTypedefs,
            currentTypes,
            variableRegex,  // typedefs look like variable declarations
            true);          // expand data type regex and return result

        // move scope to function's body
        stop = findCloser(localScopeRegex.lastIndex, "{", "}");
        local.set(localScopeRegex.lastIndex, stop - 1);

        // style parameters and local enumerations
        styleTokens("parameter", match, parameterRegex);
        styleIdentifiers("enumConstant",
            styleTokens, enumRegex, enumConstantRegex);

        // style local variables and local typedefs
        // current types is only expanded until end of current scope
        styleIdentifiers([ "localVariable", "typedef" ],
            styleVariables, currentTypes, variableRegex, true);

        // resume search at end of local scope
        localScopeRegex.lastIndex = stop;
    }

    // style function names - both known and probable
    quickStyle( "function", functions.join("|"));
    styleGroups("function", addFunction, functionRegex);

    local.clear();
}

// update styling for text currently entered in typing area
function styleEditbox() {

    // get current text, remove styling, and normalize tag structure
    const editbox  = document.getElementById("editbox");
    const unstyled = initializeGlobals(editbox.innerHTML);

    // style comments and hide from future searches
    styleMatches("comment", hideMatch, commentRegex);

    // style string and numeric literals, including #include files
    styleMatches("literal", splitMatch, stringRegex);
    styleGroups( "literal", addGroup,   systemFileRegex);
    styleMatches("literal", addMatch,   numberRegex);

    // style preprocessor directives, including macros
    styleMatches("preprocessor", addMatch, preprocessorRegex);
    styleGroups( "macro",        addMacro, macroRegex);

    // style keywords and tag types
    styleMatches("keyword", addMatch, keywordRegex);
    styleGroups( "tagType", addGroup, tagTypeRegex);

    // style local identifiers and function names
    sanitizeCurrentText();  // simplify a few things first
    styleLocalScopes();

    // style global enumerations
    styleIdentifiers("enumConstant",
        styleTokens, enumRegex, enumConstantRegex);

    // style global variables and global typedefs
    styleIdentifiers([ "globalVariable", "typedef" ],
        styleVariables, dataTypeRegex, variableRegex, true);

    // replace previous text with newly styled text
    // maintainCaret() defined in next section below
    maintainCaret(editbox, applyStyles(unstyled));
}

// -----------------------------------------------------------------------------
// manage caret position

// get length of node in characters, accounting for linebreaks
function nodeLength(node) {

    let length = node.textContent.length;

    // linebreaks add 1 extra character
    if (node.nodeName             === "DIV" || (  // break after line
        node.nextSibling          !== null  &&
        node.nextSibling.nodeName === "DIV" )) {  // break before next

        length++;
    }

    return length;
}

// convert selection range into character offset
function offsetFromRange(editbox, range) {

    let node   = range.endContainer;
    let offset = range.endOffset;

    if (node === editbox || editbox.contains(node) === false) {
        return 0;  // selection not inside editbox - caret goes at top
    }

    // step backward through node hierarchy to find total offset
    else while (node !== editbox) {

        // step backward through siblings
        while (node.previousSibling !== null) {
            node    = node.previousSibling;
            offset += nodeLength(node);
        }

        // go up 1 level when no more siblings
        node = node.parentNode;
    }

    // return total offset from beginning of editbox
    return offset;
}

// -------------------------------------

// return selection range for target caret location
function buildRange(node, offset) {

    // check if offset is out of bounds
    if (offset > node.textContent.length) {
        offset = node.textContent.length;
    }

    const range = document.createRange();
    range.setEnd(node, offset);
    range.collapse();  // collapse to end point just set

    return range;
}

// convert character offset into selection range
function rangeFromOffset(editbox, offset) {

    let node = editbox.firstChild;
    if (node === null) {
        return buildRange(editbox, 0);  // editbox was empty
    }

    // step forward through node hierarchy by total offset amount
    while (true) {

        const length = nodeLength(node);
        if (offset >= length) {  // is offset past current node?

            // should never happen, but just in case
            if (node.nextSibling === null) {
                break;
            }

            node    = node.nextSibling;
            offset -= length;  // track offset remaining

        } else {  // offset is within current node

            if (node.firstChild === null) {
                break;  // already at bottom of hierarchy
            }

            // go down 1 level for more fine-grain control
            node = node.firstChild;
        }
    }

    // ensure we are at bottom of node hierarchy
    while (node.firstChild !== null) {
        node = node.firstChild;
    }

    // create Range object representing current position
    return buildRange(node, offset);
}

// -------------------------------------

// remember caret location and restore after updating text
function maintainCaret(editbox, html) {

    // check if caret is active
    const selection = window.getSelection();
    if (selection            === null   ||
        selection.type       === "None" ||
        selection.rangeCount === 0) {

        editbox.innerHTML = html;  // caret not active
        return;
    }

    // save caret position, then update editbox text
    const offset = offsetFromRange(editbox, selection.getRangeAt(0));
    editbox.innerHTML = html;

    // restore caret position from offset
    selection.removeAllRanges();
    selection.addRange(rangeFromOffset(editbox, offset));
}

// -----------------------------------------------------------------------------
// manage notifications

// find matching Context object, or create it if not found
function getContext(filename) {

    // remove extraneous characters and HTML entities
    filename = filename
        .replace(/<|&lt;/g,   "")
        .replace(/>|&gt;/g,   "")
        .replace(/"|&quot;/g, "");

    // look for existing Context object
    let context = contexts.find(function(c) {
        return c.filename === filename; });

    // create object if not found
    if (context === undefined) {

        context = new Context(filename);
        contexts.push(context);  // save reference in global array
    }

    return context;
}

// scan through all input for #include files matching regex
// using getContext() prevents duplicate entries for same filename
function findContext(allInput, regex) {

    for (let match = regex.exec(allInput);
             match !== null;
             match = regex.exec(allInput)) {

        // remove linebreaks and whitespace
        // match[1] is capture group containing filename
        const filename = match[1]
            .replace(linebreakRegex, "")
            .trim();

        const context = getContext(filename);  // get or create

        // remember if filename was surrounded by angle brackets
        context.systemFile = (filename.indexOf("&lt;") !== -1);
    }
}

// cascade notifications down right side of typing area
function positionNotifications() {

    let offset = 0;  // total offset from first notification

    // loop through all contexts with notifications
    for (let i = 0; i < contexts.length; i++) {
        if (contexts[i].notification !== null) {

            // if notification at top of stack, don't offset
            if (offset === 0) {
                contexts[i].notification.style.transform = "";
            }

            // otherwise, position below previous notification
            else {
                contexts[i].notification.style.transform =
                    "translateY(" + offset + "em)";
            }

            offset += 7;  // increase next offset to use
        }
    }
}

const dismissed = " ";  // mark as notification dismissed

// remove previously shown notification for missing context data
function dismissNotification(filename, rescan = false) {

    const context = getContext(filename);

    // if present, remove notification from page
    if (context.notification !== null) {

        const container = document.getElementById("container");
        container.removeChild(context.notification);
        context.notification = null;  // also remove from object
    }

    // if context still missing, mark notification as dismissed
    if (rescan === false && context.fileData === "") {
        context.fileData = dismissed;  // technically not empty
    }

    // reposition remaining notifications
    positionNotifications();
}

// create notifications for #include files with missing context data
function createNotifications(allInput) {

    const container = document.getElementById("container");

    // find any new #include files
    findContext(allInput, systemFileRegex);
    findContext(allInput, projectFileRegex);

    // loop through all context entries
    for (let i = 0; i < contexts.length; i++) {

        // clear previous notification
        dismissNotification(contexts[i].filename, true);  // allow rescan

        // if context is missing file data, create notification
        if (contexts[i].fileData === "") {

            // create notification message
            let message = "Import header file?<br>";

            // add filename of missing file
            message += "<span class='indent'>"   +
                       contexts[i].getFilename() +
                       "</span>";

            // add blank line before buttons
            message += "<br><br>";

            // add button to import missing file
            message += "<input type='button' "     +
                              "value='Import' "    +
                              "class='floatLeft' " +
                              "onclick='importContext()'>";

            // add button to dismiss notification
            message += "<input type='button' "      +
                              "value='Dismiss' "    +
                              "class='floatRight' " +
                              "onclick='dismissNotification(\"" +
                                  contexts[i].filename + "\")'>";

            // create notification <div> to hold message and buttons
            const notification     = document.createElement("div");
            notification.className = "notification";
            notification.innerHTML = message;

            // display notification and save reference for later
            container.appendChild(notification);
            contexts[i].notification = notification;
        }
    }

    // position all notifications at once
    positionNotifications();
}

// -----------------------------------------------------------------------------
// event handlers

// EVENT LISTENER: display caret position as line/column numbers
// triggered by clicking on typing area and pressing keys
function updateCaretPosition() {

    const editbox       = document.getElementById("editbox");
    const caretPosition = document.getElementById("caretPosition");

    // check if caret is active
    const selection = window.getSelection();
    if (selection            === null   ||
        selection.type       === "None" ||
        selection.rangeCount === 0) {

        caretPosition.innerHTML = "&nbsp;";  // no position to display
        return;
    }

    // check if caret inside editbox
    const range = selection.getRangeAt(0);
    if (editbox.contains(range.endContainer) === false) {

        caretPosition.innerHTML = "&nbsp;";  // no position to display
        return;
    }

    // step forward through node hierarchy, counting lines/columns
    let line   = 1;
    let column = 1;
    let node   = editbox.firstChild;
    while (node !== null) {

        // account for when previous node was not inside <div> tag
        if (node.nodeName                 === "DIV" &&
            node.previousSibling          !== null  &&
            node.previousSibling.nodeName !== "DIV") {

            line++;
            column = 1;  // reset column number
        }

        // is caret inside current node?
        if (node === range.endContainer) {

            // display current line and column values on toolbar
            caretPosition.innerHTML =
                "Ln "    +  line   +
                ", Col " + (column + range.endOffset);
            return;

        // is caret after current node?
        } else if (node.contains(range.endContainer) === false) {

            if (node.nextSibling === null) {
                break;  // should never happen, but just in case
            }

            if (node.nodeName === "DIV") {  // handle <div> nodes
                line++;
                column = 1;  // reset column number
            }
            else {  // sum up length of all other node types
                column += nodeLength(node);
            }

            node = node.nextSibling;  // step forward

        // caret must be inside nested child
        } else {

            if (node.firstChild === null) {
                break;  // should never happen, but just in case
            }

            // go down 1 level for more fine-grain control
            node = node.firstChild;
        }
    }

    // display default text if typing area is empty or error occurs
    caretPosition.innerHTML = "Ln 1, Col 1";
    return;
}

// -------------------------------------

let hasChanges = false;  // dirty flag for typing area
let updateTimer;         // debouncing timer

// EVENT LISTENER: triggered by all user input
function updateEditbox() {

    hasChanges = true;  // set dirty flag

    // after no typing for 2 seconds, update styling
    clearTimeout(updateTimer);
    updateTimer = setTimeout(styleEditbox, 2000);
}

// ask if user wants to save changes
function dropChanges() {

    return hasChanges === false ||
           confirm("You will lose any unsaved changes.");
}

// BUTTON ACTION: discard all context previously loaded
function discardContext() {

    // clear old notifications from screen
    for (let i = 0; i < contexts.length; i++) {
        dismissNotification(contexts[i].filename, true);
    }

    contexts.length = 0;
    styleEditbox();  // rescan and create notifications
}

// BUTTON ACTION: delete contents of typing area
function clearEditbox() {

    if (dropChanges() === false) {
        return;
    }

    // reset page elements to default values
    document.getElementById("editbox").innerHTML = "";
    document.getElementById("filename").value    = "NewFile.txt";
    hasChanges                                   = false;

    discardContext();       // clear old notifications
    updateCaretPosition();  // reset caret position text
}

// -------------------------------------

// load file data into main typing area and update filename textbox
function displayFile(filename, fileData) {

    // update filename control
    if (filename.indexOf(".") === -1) {
        filename += ".";  // denotes no file extension
    }
    document.getElementById("filename").value = filename;

    // load file data into typing area and clear dirty flag
    document.getElementById("editbox").innerHTML = fileData;
    hasChanges                                   = false;

    styleEditbox();         // style newly loaded text
    updateCaretPosition();  // reset caret position text
}

// handler function to use to finish loading file
let afterUpload = displayFile;

// EVENT LISTENER: triggered by closing file picker dialog box
// "this" is file picker control which function is attached to
function uploadFile() {

    // check if user cancelled file picker
    if (this.files.length === 0) {
        return;
    }

    const filePicker = this;  // save reference for closure below

    // create and initialize file reader object
    const fileReader = new FileReader();
    fileReader.addEventListener("load", function() {

        // sanitize file data and convert newline characters
        let fileData = fileReader.result
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(newlineRegex, newline);

        // add opening/closing <div> tags and insert <br> tags
        fileData = "<div>" + fileData + "</div>";
        fileData = fileData.replace(emptyLineRegex, emptyLine);

        // pass filename and file data to afterUpload() handler
        afterUpload(filePicker.files[0].name, fileData);
        filePicker.value = "";  // reset file picker control for reuse
    });

    // read selected file, triggering load listener defined above
    fileReader.readAsText(this.files[0]);
}

// BUTTON ACTION: open file picker dialog box
function selectFile() {

    // confirm dropping changes only if opening file for editing
    if (afterUpload === displayFile && dropChanges() === false) {
        return;
    }

    const filePicker = document.getElementById("filePicker");

    // simulate user clicking on hidden file picker control
    filePicker.disabled = false;  // starts disabled
    filePicker.click();
    filePicker.disabled = true;
}

// -------------------------------------

// load file data into Context object with matching filename
function saveContext(filename, fileData) {

    // find or create Context matching object
    const context    = getContext(filename);
    context.fileData = fileData;  // save file data for later

    dismissNotification(filename);

    afterUpload = displayFile;  // swap "after upload" handler back
    styleEditbox();             // re-style text using new context
}

// BUTTON ACTION: import context into current file's namespace
function importContext() {

    // swap after upload handler, then trigger file picker dialog box
    // recycles all other parts of loading files
    afterUpload = saveContext;
    selectFile();
}

// BUTTON ACTION: restore previously dismissed notifications
function scanForContext() {

    // loop through all context objects
    for (let i = 0; i < contexts.length; i++) {
        if (contexts[i].fileData === dismissed) {
            contexts[i].fileData = "";  // unflag object
        }
    }

    styleEditbox();  // rescan and create notifications
}

// -------------------------------------

// BUTTON ACTION: save contents of typing area to "Downloads" folder
function downloadFile() {

    let fileType      = "text/plain";
    let filenameParts = document.getElementById("filename").value
        .replace(filenameRegex, "_")  // remove invalid symbols
        .trim()
        .split(".");  // split actual filename from extension

    // determine filename
    let filename = filenameParts[0];
    if (filename === "") {
        filename = "NewFile";  // use default filename
    }

    // determine extension
    if (filenameParts.length === 1) {
        filename += ".txt";  // use default extension
    }
    else if (filenameParts[1] !== "") {
        filename += "." + filenameParts[1];  // keep extension
    }
    else {
        // original filename ended with period, so no extension
        // switch to a file type with no default extension
        fileType = "application/octet-stream";
    }

    // convert HTML to plain text - many HTML tags are just discarded
    const fileData = document.getElementById("editbox").innerHTML
        .replace(stylingRegex,    "")
        .replace(/<\/div><div>/g, "\n")  // convert normal newlines
        .replace(/^<div>/,        "")    // remove opening <div>
        .replace(/<\/div>$/,      "")    // remove closing </div>
        .replace(/<br>/g,         "")
        .replace(/<\/?div>/g,     "\n")  // convert abnormal newlines
        .replace(/&lt;/g,         "<")
        .replace(/&gt;/g,         ">");

    // create temporary download link
    const file    = new Blob([ fileData ], { type: fileType });
    const url     = URL.createObjectURL(file);
    const link    = document.createElement("a");
    link.href     = url;
    link.download = filename;

    // simulate user clicking temporary download link, then clean up
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);  // free up resources

    hasChanges = false;  // clear dirty flag
}

// -------------------------------------

// EVENT LISTENER: triggered by user trying to leave page
function exitPage(event) {

    if (hasChanges === true) {

        // check which method current browser supports
        if (typeof event.preventDefault === "function") {
            event.preventDefault();         // for newer browsers
        } else {
            event.returnValue = "confirm";  // for older browsers
        }
    }
}

// attach event listeners and prepare page for user
function initializePage() {

    window.addEventListener("beforeunload", exitPage);

    document.getElementById("filePicker")
        .addEventListener("change", uploadFile);

    const editbox = document.getElementById("editbox");
    editbox.addEventListener("input",   updateEditbox);
    editbox.addEventListener("click",   updateCaretPosition);
    editbox.addEventListener("keydown", updateCaretPosition);
    editbox.addEventListener("keyup",   updateCaretPosition);

    clearEditbox();  // same as clicking "New File" button
}

// -----------------------------------------------------------------------------
    </script>

</head>
<body onload="initializePage()">
<div id="layout">

    <div id="toolbar">

        <div><!-- group textbox and its label at top -->
            <label for="filename">Current File:</label>
            <input id="filename"
                   type="text">
        </div>

        <!-- hidden behind other controls -->
        <input type="file"
               id="filePicker"
               accept="text/plain,.h,.hpp"
               disabled><!-- enabled only when needed -->

        <input type="button"
               value="New File"
               onclick="clearEditbox()">

        <!-- triggers above file picker control -->
        <input type="button"
               value="Open File"
               onclick="selectFile()">

        <input type="button"
               value="Save to Downloads"
               onclick="downloadFile()">

        |<!-- separate buttons into groups -->

        <input type="button"
               value="Import Header"
               onclick="importContext()">

        <input type="button"
               value="Discard Imports"
               onclick="discardContext()">

        <input type="button"
               value="Rescan #includes"
               onclick="scanForContext()">

    </div><!-- end of toolbar -->

    <!-- additional container to position notifications -->
    <div id="container">

        <div id="editbox"
             contenteditable="true"
             spellcheck="false"></div>

    </div><!-- end of container -->

    <div id="caretPosition"></div>

</div><!-- end of layout -->
</body>
</html>
