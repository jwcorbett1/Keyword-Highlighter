<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Keyword Highlighter</title>

    <style>
/* -------------------------------------------------------------------------- */

body, input {
    font-family: "Courier New", Courier, monospace;
}

.viewPort {
    display:        flex;
    flex-direction: column;
    width:          85vw;
    height:         85vh;
    margin:         1.5em auto 0;
    padding:        0;
}

#editBox {
    flex-grow:   1;
    white-space: preserve nowrap;
    overflow:    auto;
    border:      0.1em solid black;
    outline:     none;
    margin:      0;
    padding:     0.6em 0.8em;
}

.toolBar {
    flex-grow: 0;
    margin:    0;
    padding:   0 0 0.7em;
}

#filePicker {
    position: absolute;
    z-index:  -1;
    opacity:  0;
}

#fileName {
    width: 40em;
}

.keyword {
    color: blue;
}

.literal {
    color: red;
}

.comment {
    color: green;
}

/* -------------------------------------------------------------------------- */
    </style>
    <script>
// -----------------------------------------------------------------------------

class StringToken {

    constructor(string, start, style) {
        this.string = string;
        this.start  = start;
        this.style  = style;
    }

    get end() {
        return this.start + this.string.length;
    }

    contains(s) {
        return this.string.indexOf(s) > -1;
    }
}

function segmentString(string, regex) {

    return string.split(regex).filter((s) => s.length > 0);
}

function tokenizeString(string, start, end, regex, nextFunc, style) {

    const segments = segmentString(string.substring(start, end), regex);
    const tokens   = [];

    let i = 0;
    while (i < segments.length) {

        if (nextFunc && !nextFunc(segments, i)) {
            continue;
        }

        start = string.indexOf(segments[i], start);
        tokens.push(new StringToken(segments[i], start, style));
        start += segments[i].length;

        i++;
    }

    return tokens;
}

function splitSegment(segments, index, regex) {

    const newSegments = segmentString(segments[index], regex);

    if (newSegments.length > 0) {
        segments.splice(index, 1, ...newSegments);
        return true;
    }

    else {
        segments.splice(index, 1);
        return false;
    }
}

function validateSegment(segments, index) {

    let valid = true;

    if (segments[index].indexOf("#") > 0) {
        valid = splitSegment(segments, index, /(?<!^)#/);
    }

    if (segments[index].indexOf("-") > 0) {
        valid = valid && splitSegment(segments, index, /(?<!^)(?<!e)-/i);
    }

    if (segments[index].search(/-?\.?\d/) != 0) {
        valid = valid && splitSegment(segments, index, ".");
    }

    return valid;
}

function buildStyledHTML(string, tokens) {

    const styles = tokens.filter((t) => t.style != "");
    if (styles.length < 1) {
        return string;
    }

    let html = string.substring(0, styles[0].start);

    for (let i = 0; i < styles.length; i++) {

        html += "<span class='" + styles[i].style + "'>";
        html += styles[i].string;
        html += "</span>";

        if (i + 1 < styles.length) {
            html += string.substring(styles[i].end, styles[i + 1].start);
        } else {
            html += string.substring(styles[i].end);
        }
    }

    return html;
}

// -----------------------------------------------------------------------------

class TokenRange {

    constructor(start, count) {
        this.start = start;
        this.count = count;
    }
}

function selectTokens(tokens, start, end, delimiter) {

    const range = new TokenRange(tokens.length > 0 ? -1 : 0, 0);

    for (let i = 0; i < tokens.length; i++) {

        if (tokens[i].start < start) {
            continue;
        }

        if (range.start < 0) {
            if (i > 0 && tokens[i - 1].contains(delimiter)) {
                break;
            }
            range.start = i;
        }

        if (tokens[i].start >= end) {
            break;
        }

        range.count++;
    }

    return range;
}

function styleByDelimiters(string, delimiters, tokens, style) {

    let end;
    for (let start = string.indexOf(delimiters[0]);
             start > -1;
             start = string.indexOf(delimiters[0], end)) {

        end = string.indexOf(delimiters[1], start + delimiters[0].length);
        if (end > -1) {
            end += delimiters[1].length;
        } else {
            end  = string.length;
        }

        const range = selectTokens(tokens, start, end, delimiters[0]);
        if (range.start < 0) {
            continue;
        }

        const newTokens = tokenizeString(string, start, end,
            /<\/?div[^>]*>|<br>/i, null, style);

        tokens.splice(range.start, range.count, ...newTokens);
    }
}

function styleByList(list, tokens, style) {

    for (let i = 0; i < tokens.length; i++) {
        for (let j = 0; j < list.length; j++) {

            if (tokens[i].string == list[j]) {
                tokens[i].style  =  style;
            }
        }
    }
}

function styleByRegex(regex, tokens, style) {

    for (let i = 0; i < tokens.length; i++) {

        if (regex.test(tokens[i].string)) {
            tokens[i].style = style;
        }
    }
}

// -----------------------------------------------------------------------------

const dataTypes = [
    "bool",
    "char",
    "double",
    "float",
    "int",
    "long",
    "short",
    "signed",
    "unsigned",
    "void",
    "wchar_t"
];

const userDefined = [
    "#define",
    "enum",
    "struct",
    "typedef",
    "union"
];

const keywords = [
    "#elif",
    "#else",
    "#endif",
    "#error",
    "#if",
    "#ifdef",
    "#ifndef",
    "#include",
    "#pragma",
    "#undef",
    "auto",
    "break",
    "case",
    "const",
    "continue",
    "default",
    "do",
    "else",
    "extern",
    "for",
    "goto",
    "if",
    "register",
    "return",
    "sizeof",
    "static",
    "switch",
    "volatile",
    "while"
];

function getUnstyledHTML(element) {

    let html = element.innerHTML;
        html = html.replace(/<span[^>]*>/g, "");
        html = html.replace(/<font[^>]*>/g, "");
        html = html.replace(/<\/span>/g, "");
        html = html.replace(/<\/font>/g, "");

    return html;
}

function saveCaret(element, html) {

    const selection = window.getSelection();
    if (selection && selection.rangeCount < 1) {
        element.innerHTML = html;
        return;
    }

    const range = selection.getRangeAt(0).cloneRange();
    range.setStart(element, 0);
    let caret = range.toString().length;

    element.innerHTML = html;

    const tree = document.createTreeWalker(element, NodeFilter.SHOW_TEXT);
    while (tree.nextNode() && caret > tree.currentNode.length) {
        caret -= tree.currentNode.length;
    }
    caret = Math.min(caret, tree.currentNode.length);

    range.setStart(tree.currentNode, caret);
    range.collapse(true);
    selection.removeAllRanges();
    selection.addRange(range);
}

function styleEditBox() {

    const editBox = document.getElementById("editBox");
    const html    = getUnstyledHTML(editBox);
    const tokens  = tokenizeString(html, 0, html.length,
        /[^\w#.-]+/, validateSegment, "");

    styleByDelimiters(html, ["/*", "*/"], tokens, "comment");
    styleByDelimiters(html, ["\'", "\'"], tokens, "literal");
    styleByDelimiters(html, ["\"", "\""], tokens, "literal");

    styleByRegex(/^-?\.?\d/, tokens, "literal");

    styleByList(dataTypes,   tokens, "keyword");
    styleByList(userDefined, tokens, "keyword");
    styleByList(keywords,    tokens, "keyword");

    saveCaret(editBox, buildStyledHTML(html, tokens));
}

let stylingTimer;
function debounceStyling() {

    editBoxDirty = true;

    clearTimeout(stylingTimer);
    stylingTimer = setTimeout(styleEditBox, 2000);
}

// -----------------------------------------------------------------------------

let editBoxDirty = false;
function clearEditBox() {

    if (editBoxDirty && !confirm("You will lose any unsaved changes.")) {
        return;
    }

    document.getElementById("editBox").innerHTML = "";
    document.getElementById("fileName").value    = "temp.txt";
    editBoxDirty                                 = false;
}

function pickFile() {

    if (editBoxDirty && !confirm("You will lose any unsaved changes.")) {
        return;
    }

    document.getElementById("filePicker").click();
}

function loadFile(content) {

    content = content.replace(/</g, "&lt;").replace(/>/g, "&gt;");

    const editBox = document.getElementById("editBox");
    const lines   = content.split(/\r*\n|\r/);

    if (lines.length < 2) {
        editBox.innerHTML = lines[0];
    } else {

        let html = "";
        for (let index = 0; index < lines.length; index++) {

            if (lines[index].length < 1) {
                lines[index] = "<br>";
            }
            html += "<div>" + lines[index] + "</div>";
        }

        editBox.innerHTML = html;
    }

    styleEditBox();
    editBoxDirty = false;
}

function readFile() {

    if (this.files.length > 0) {

        let fileName = this.files[0].name;
        if (fileName.indexOf(".") < 0) {
            fileName += ".";
        }
        document.getElementById("fileName").value = fileName;

        const reader = new FileReader();
        reader.addEventListener("load", function () {
            loadFile(reader.result);
        });

        reader.readAsText(this.files[0]);
        this.value = "";
    }
}

function downloadFile() {

    let fileType = "text/plain";
    let fileName = document.getElementById("fileName").value;

    if (fileName[fileName.length - 1] == ".") {
        fileType = "application/octet-stream";
        fileName = fileName.substring(0, fileName.length - 1);
    }
    else if (fileName.indexOf(".") < 0) {
        fileName += ".txt";
    }

    let content = getUnstyledHTML(document.getElementById("editBox"));
        content = content.replace(/&lt;/g,        "<");
        content = content.replace(/&gt;/g,        ">");
        content = content.replace(/<div[^>]*>/gi, "\n");
        content = content.replace(/<\/div>/gi,    "");
        content = content.replace(/<br>/gi,       "");

    if (content[0] == "\n") {
        content = content.substring(1);
    }

    const url = URL.createObjectURL(new Blob(
        [content],
        { type: fileType }
    ));

    const link          = document.createElement("a");
          link.href     = url;
          link.download = fileName;

    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    URL.revokeObjectURL(url);
    editBoxDirty = false;
}

// -----------------------------------------------------------------------------

function onPageLoad() {

    document
        .getElementById("filePicker")
        .addEventListener("change", readFile);

    document
        .getElementById("editBox")
        .addEventListener("input", debounceStyling);

    clearEditBox();
}

// -----------------------------------------------------------------------------
    </script>

</head>
<body onload="onPageLoad()">

    <div class="viewPort">
        <div class="toolBar">

            <input type="button"
                   value="New File"
                   onclick="clearEditBox()">

            <input type="file"
                   id="filePicker"
                   accept="text/plain">

            <input type="button"
                   value="Open File"
                   onclick="pickFile()">

            <input type="button"
                   value="Save to Downloads"
                   onclick="downloadFile()">

            <label for="fileName">Current File:</label>
            <input type="text" id="fileName">

        </div>
        <div id="editBox" contenteditable="true" spellcheck="false"></div>
    </div>

</body>
</html>
