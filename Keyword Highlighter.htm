<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0">

    <title>Keyword Highlighter</title>

    <style>
/* -------------------------------------------------------------------------- */

/* font settings for all text and controls */
body, input {
    font-family: "Courier New", Courier, monospace;
}

/* top-level flexbox */
.viewPort {
    display:        flex;
    flex-direction: column;
    width:          85vw;
    height:         85vh;
    margin:         1.5em auto 0;
    padding:        0;
}

#editBox {
    flex-grow:   1;     /* fill majority of viewport */
    white-space: preserve nowrap;
    overflow:    auto;  /* add scrollbars if/when needed */
    border:      0.1em solid black;
    outline:     none;
    margin:      0;
    padding:     0.6em 0.8em;
}

.toolBar {
    flex-grow: 0;  /* minimize footprint */
    margin:    0;
    padding:   0 0 0.7em;
}

/* invisible and hidden behind other controls */
#filePicker {
    position: absolute;
    z-index:  -1;
    opacity:  0;
}

#fileName {
    width: 40em;
}

/* -------------------------------------------------------------------------- */
/* colors to use for each type of token */

.comment {
    color: green;
}

.literal {
    color: red;
}

.keyword {
    color: blue;
}

.preprocessor {
    color: gray;
}

.macro {
    color: purple;
}

.function {
    color: orange;
}

.variable {
    color: yellow;
}

.userDefined {
    color: cyan;
}

/* -------------------------------------------------------------------------- */
    </style>
    <script>
// -----------------------------------------------------------------------------
// keywords divided up by handling needs

const dataType = [
    "bool",
    "char",
    "double",
    "float",
    "int",
    "long",
    "short",
    "signed",
    "unsigned",
    "void",
    "wchar_t"
];

const userDefined = [
    "enum",
    "struct",
    "union"
];

// #define handled separately
const preprocessor = [
    "#elif",
    "#else",
    "#endif",
    "#error",
    "#if",
    "#ifdef",
    "#ifndef",
    "#include",
    "#pragma",
    "#undef"
];

// typedef handled separately
const keyword = [
    "auto",
    "break",
    "case",
    "const",
    "continue",
    "default",
    "do",
    "else",
    "extern",
    "for",
    "goto",
    "if",
    "register",
    "return",
    "sizeof",
    "static",
    "switch",
    "volatile",
    "while"
];

// -----------------------------------------------------------------------------

// base-level data structure
class Styling {

    constructor(style, start, stop) {

        this.style = style;
        this.start = start;  // first index to apply style
        this.stop  = stop;   // first index to stop applying style
    }
}

// embed Styling data into text and return result
// requires styles to be sorted by start index
function buildStyledHTML(text, styles) {

    let html = text.substring(0, styles[0].start);  // before any styling
    for (let i = 0; i < styles.length; i++) {

        html += "<span class='" + styles[i].style + "'>" +
                text.substring(styles[i].start, styles[i].stop) +
                "</span>";

        if (i + 1 < styles.length) {
            html += text.substring(styles[i].stop, styles[i + 1].start);
        } else {
            html += text.substring(styles[i].stop);  // until end of text
        }
    }

    return html;
}

// -----------------------------------------------------------------------------

// builder to apply styling step-by-step
class StyleBuilder {

    constructor(html) {

        this.original = html;  // copy for creating styled HTML
        this.edited   = html;  // copy without "hidden" text
        this.styling  = [];    // holds Styling objects

        // range to use for regex searches
        this.startAt  = 0;            // first index to start searching
        this.stopAt   = html.length;  // first index to stop searching
    }

    // ---------------------------------

    // in future, search only part of edited string
    setScope(startAt, stopAt) {

        this.startAt = startAt;
        this.stopAt  = stopAt;
    }

    // in future, search entire edited string
    clearScope() {

        this.startAt = 0;
        this.stopAt  = this.original.length;
    }

    // ---------------------------------

    addStyling(style, start, stop) {

        // check if start/stop overlaps existing styling
        for (let i = 0; i < this.styling.length; i++) {

            if (start < this.styling[i].stop &&
                this.styling[i].start < stop) {

                return;  // overlap not allowed!
            }
        }

        this.styling.push(new Styling(style, start, stop));
    }

    // remove all Styling objects with this style
    removeStyling(style) {

        this.styling = this.styling
            .filter(function(s) { return s.style !== style; });
    }

    // ---------------------------------

    // add styling, but skip over regex matches
    splitStyling(style, start, stop, regex) {

        const segments = this.edited
            .substring(start, stop)
            .split(regex)
            .filter(function(s) { return s.length > 0; });

        stop = start;  // no previous match
        for (let i = 0; i < segments.length; i++) {

            // find match after end of previous match
            start = this.edited.indexOf(segments[i], stop);
            stop  = start + segments[i].length;

            this.addStyling(style, start, stop);
        }
    }

    // replace text with same number of filler characters
    hideRange(start, stop, begin = "", end = "") {

        this.edited =
            this.edited.substring(0, start) +
            begin +  // optional - marks beginning of deletion
            " ".repeat((stop - start) - (begin.length + end.length)) +
            end +    // optional - marks end of deletion
            this.edited.substring(stop);
    }

    // add styling to and/or hide regex matches
    // beginMark = "" and endMark = "" will fully hide matches
    // only searches between this.startAt and this.stopAt
    updateMatchedText(regex, style = "",
        splitRegex = null, beginMark = null, endMark = null) {

        regex.lastIndex = this.startAt;

        for (let match = regex.exec(this.edited);
                 match !== null;
                 match = regex.exec(this.edited)) {

            const start = match.index;
            const stop  = start + match[0].length;

            if (stop > this.stopAt) {
                break;
            }

            if (style !== "") {
                if (splitRegex === null) {
                    this.addStyling(style, start, stop);
                } else {
                    this.splitStyling(style, start, stop, splitRegex);
                }
            }

            if (beginMark !== null) {
                this.hideRange(start, stop, beginMark, endMark);
            }
        }
    }

    // ---------------------------------

    // add styling to each capture group at same time
    // styles = ["", "example"] only styles 2nd capture group
    addCaptureGroups(match, styles) {

        for (let i = 0;
                 i < styles.length && i + 1 < match.length;
                 i++) {

            if (styles[i] !== "") {

                const start = match.index +
                              match[0].indexOf(match[i + 1]);

                this.addStyling(
                    styles[i],
                    start,
                    start + match[i + 1].length);
            }
        }
    }

    // builds list of unique capture group results with each call
    // groups = [null, [] ] only records 2nd capture group results
    addUniqueCaptures(match, groups) {

        for (let i = 0;
                 i < groups.length && i + 1 < match.length;
                 i++) {

            if (groups[i] !== null && !groups[i].includes(match[i + 1])) {

                groups[i].push(match[i + 1]);
            }
        }
    }

    // add styling to and/or build list of capture group matches
    // only searches between this.startAt and this.stopAt
    findCaptureGroups(regex, styles = null, groups = null) {

        regex.lastIndex = this.startAt;

        for (let match = regex.exec(this.edited);
                 match !== null &&
                 match.index + match[0].length <= this.stopAt;
                 match = regex.exec(this.edited)) {

            if (styles !== null) {
                this.addCaptureGroups(match, styles);
            }

            if (groups !== null) {
                this.addUniqueCaptures(match, groups);
            }
        }
    }

    // ---------------------------------

    // embed current styling into original HTML and return result
    buildStyledHTML() {

        if (this.styling.length === 0) {
            return this.original;
        }

        // buildStyledHTML() requires array to be sorted by start index
        this.styling.sort(function(a, b) { return a.start - b.start; });

        return buildStyledHTML(this.original, this.styling);
    }
}

// -----------------------------------------------------------------------------
/*
class StringToken {

    constructor(string, start, style) {
        this.string = string;
        this.start  = start;
        this.style  = style;
    }

    get end() {
        return this.start + this.string.length;
    }

    contains(s) {
        return this.string.indexOf(s) > -1;
    }
}

function segmentString(string, regex) {

    return string.split(regex).filter((s) => s.length > 0);
}

function tokenizeString(string, start, end, regex, nextFunc, style) {

    const segments = segmentString(string.substring(start, end), regex);
    const tokens   = [];

    let i = 0;
    while (i < segments.length) {

        if (nextFunc && !nextFunc(segments, i)) {
            continue;
        }

        start = string.indexOf(segments[i], start);
        tokens.push(new StringToken(segments[i], start, style));
        start += segments[i].length;

        i++;
    }

    return tokens;
}

function splitSegment(segments, index, regex) {

    const newSegments = segmentString(segments[index], regex);

    if (newSegments.length > 0) {
        segments.splice(index, 1, ...newSegments);
        return true;
    }

    else {
        segments.splice(index, 1);
        return false;
    }
}

function validateSegment(segments, index) {

    let valid = true;

    if (segments[index].indexOf("#") > 0) {
        valid = splitSegment(segments, index, /(?<!^)#/);
    }

    if (segments[index].indexOf("-") > 0) {
        valid = valid && splitSegment(segments, index, /(?<!^)(?<!e)-/i);
    }

    if (segments[index].search(/-?\.?\d/) != 0) {
        valid = valid && splitSegment(segments, index, ".");
    }

    return valid;
}

function ignoreAnnotations(tokens, annotations) {

    let styles = tokens.filter((t) => t.style != "");

    for (let i = 0; i < annotations.length; i++) {
        styles = styles.filter((t) => t.styles != annotations[i]);
    }

    return styles;
}

function old_buildStyledHTML(string, tokens, annotations) {

    const styles = ignoreAnnotations(tokens, annotations);
    if (styles.length < 1) {
        return string;
    }

    let html = string.substring(0, styles[0].start);

    for (let i = 0; i < styles.length; i++) {

        html += "<span class='"  + styles[i].style + "'>" +
                styles[i].string +
                "</span>";

        if (i + 1 < styles.length) {
            html += string.substring(styles[i].end, styles[i + 1].start);
        } else {
            html += string.substring(styles[i].end);
        }
    }

    return html;
}

// -----------------------------------------------------------------------------

class TokenRange {

    constructor() {
        this.start = 0;
        this.count = 0;
    }
}

function selectTokens(tokens, start, end, delimiter) {

    const range = new TokenRange();
    if (tokens.length > 0) {
        range.start = -1;
    }

    for (let i = 0; i < tokens.length; i++) {

        if (tokens[i].start < start) {
            continue;
        }

        if (range.start < 0) {
            if (i > 0 && tokens[i - 1].contains(delimiter)) {
                break;
            }
            range.start = i;
        }

        if (tokens[i].start >= end) {
            break;
        }

        range.count++;
    }

    return range;
}

function styleByDelimiters(string, delimiters, tokens, style) {

    let end;
    for (let start = string.indexOf(delimiters[0]);
             start > -1;
             start = string.indexOf(delimiters[0], end)) {

        end = string.indexOf(delimiters[1], start + delimiters[0].length);
        if (end > -1) {
            end += delimiters[1].length;
        } else {
            end  = string.length;
        }

        const range = selectTokens(tokens, start, end, delimiters[0]);
        if (range.start < 0) {
            continue;
        }

        const newTokens = tokenizeString(string, start, end,
            /<\/?div>|<br>/i, null, style);

        tokens.splice(range.start, range.count, ...newTokens);
    }
}

function styleByList(list, tokens, style, offset = 0) {

    for (let i = 0; i < tokens.length; i++) {
        for (let j = 0; j < list.length; j++) {

            if (tokens[i].string == list[j]) {
                tokens[i + offset].style = style;
            }
        }
    }
}

function styleByRegex(regex, tokens, style) {

    for (let i = 0; i < tokens.length; i++) {

        if (regex.test(tokens[i].string)) {
            tokens[i].style = style;
        }
    }
}

// -----------------------------------------------------------------------------

function eraseRange(string, start, end) {

    let result  = string.substring(0, start);
        result += " ".repeat(end - start);
        result += string.substring(end);

    return result;
}

function eraseTokens(string, tokens, style) {

    const ranges = tokens.filter((t) => t.style == style);

    for (let i = 0; i < ranges.length; i++) {
        string = eraseRange(string, tokens[i].start, tokens[i].end);
    }

    return string;
}

function findClosingDelimiter(string, opening, delimiters) {

    const d0 = delimiters[0].length;
    const d1 = delimiters[1].length;

    let closing = opening;
    do {

        closing = string.indexOf(delimiters[1], closing + d1);
        if (closing < 0) {
            closing = string.length;
        }

        opening = string.indexOf(delimiters[0], opening + d0);
        if (opening < 0) {
            opening = string.length;
        }

    } while (opening < closing);

    return closing;
}

function extractTopLevel(string, delimiters, tokens, styles) {

    const d0 = delimiters[0].length;
    const d1 = delimiters[1].length;

    for (let i = 0; i < styles.length; i++) {
        string = eraseTokens(string, tokens, styles[i]);
    }

    let closing;
    for (let opening = string.indexOf(delimiters[0]);
             opening > -1;
             opening = string.indexOf(delimiters[0], closing + d1)) {

        closing = findClosingDelimiter(string, opening, delimiters);
        string  = eraseRange(string, opening + d0, closing);
    }

    return string;
}

function findLastTokenBefore(index, tokens, start) {

    for (let i = start; i < tokens.length; i++) {

        if (tokens[i].start >= index) {
            return i - 1;
        }

        if (i + 1 == tokens.length) {
            return i;
        }
    }

    return -1;
}

function listFunctions(topLevel, regex, tokens) {

    const functions = [];

    let index  = 0;
    let offset = 0;
    for (let params = topLevel.search(regex);
             params > -1;
             params = topLevel.search(regex)) {

        index = findLastTokenBefore(params + offset, tokens, index + 1);
        if (index < 0) {
            break;
        }

        if (functions.at(-1) != tokens[index].string) {
            functions.push(tokens[index].string);
        }

        topLevel = topLevel.substring(params + 1);
        offset  += params + 1;
    }

    return functions;
}

function listDefinitions(tokens, keyword) {

    const definitions = [];

    for (let i = 0; i < tokens.length; i++) {
        if (tokens[i].string == keyword && i + 1 < tokens.length) {
            definitions.push(tokens[i + 1].string);
        }
    }

    return definitions;
}
*/
// -----------------------------------------------------------------------------
/*

find and erase whitespace/html
find and erase comments
find and erase character/string literals - end of line or line continuation

find integer/floating-point literals
find pre-processor commands
find keywords
find function/struct/enum/union definitions

list pre-processor defines
list functions and parameters
list local variables
list global variables
list typedefs

function findClosingDelimiter(text, opensAt, opener, closer) {

    let closesAt = opensAt;
    do {

        closesAt = text.indexOf(closer, closesAt + closer.length);
        if (closesAt < 0) {
            closesAt = text.length;
        }

        opensAt = text.indexOf(opener, opensAt + opener.length);
        if (opensAt < 0) {
            opensAt = text.length;
        }

    } while (opensAt < closesAt);

    return closesAt;
}

class CodeBlock {

    constructor(opensAt, closesAt) {

        this.opensAt    = opensAt;
        this.closesAt   = closesAt;
        this.name       = "";
        this.parameters = [];
    }

    setParameters(parameters) {

        const getParameter = /([A-Za-z_]\w*)\s*$/;

        this.parameters = parameters.split(",");
        let i = 0;
        while (i < this.parameters.length) {

            const groups = getParameter.exec(this.parameters[i]);
            if (groups === null) {
                this.parameters.splice(i, 1);
                continue;
            }

            this.parameters[i] = groups[1];
            i++;
        }
    }
}

function findCodeBlocks(string, keywords) {

    const getDetails = /([A-Za-z_]\w*)(?:\s*\(([^\)]*)\))?\s*\{/g;

    let   groups = getDetails.exec(string);
    const blocks = [];

    let closesAt;
    for (let opensAt = string.indexOf("{");
             opensAt !== -1;
             opensAt = string.indexOf("{", closesAt + 1)) {

        closesAt = findClosingDelimiter(string, opensAt, "{", "}");
        blocks.push(new CodeBlock(opensAt, closesAt));

        while (groups !== null &&
               getDetails.lastIndex < blocks.at(-1).opensAt + 1) {
            groups = getDetails.exec(string);
        }

        if (getDetails.lastIndex === blocks.at(-1).opensAt + 1 &&
            !keywords.includes(groups[1])) {

            blocks.at(-1).name = groups[1];
            if (groups.length > 2) {
                blocks.at(-1).setParameters(groups[2]);
            }
        }
    }

    return blocks;
}

*/
// -----------------------------------------------------------------------------
// all regular expressions confined to this section

// strip previously applied styles
function unstyledFromStyled(html) {

    return html
        .replace(/<span[^>]*>/gi, "")
        .replace(/<font[^>]*>/gi, "")  // added by some browsers
        .replace(/<\/span>/gi,    "")
        .replace(/<\/font>/gi,    "");
}

// convert HTML into plain text
function textFromHTML(html) {

    let text = unstyledFromStyled(html)
        .replace(/<div>/gi,        "\n")
        .replace(/<\/div>|<br>/gi, "")
        .replace(/&lt;/g,          "<")
        .replace(/&gt;/g,          ">");

    // first text element may or may not be inside a <div>
    if (text[0] == "\n") {
        text = text.substring(1);  // chop off extra newline
    }

    return text;
}

// convert plain text into unstyled HTML
function htmlFromText(text) {

    const cleanText = text
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");

    // if it might be a line break, it's a line break
    const lines = cleanText.split(/\r*\n|\r/);
    if (lines.length < 2) {
        return lines[0];
    }

    let html = "";
    for (let i = 0; i < lines.length; i++) {

        if (lines[i].length < 1) {
            lines[i] = "<br>";  // required for empty lines
        }
        html += "<div>" + lines[i] + "</div>";
    }

    return html;
}

// -------------------------------------

function styleCommentsAndLiterals(styler, splitAcrossLines) {

    // color-code C-style comments
    styler.updateMatchedText(
        /\/\*.*?\*\//g,    // regex to match against
        "comment",         // which CSS style to apply
        splitAcrossLines,  // ensure HTML tags are nested correctly
        "", "");           // hide text from further examination

    // color-code character literals and strings
    styler.updateMatchedText(
        /(['"]).*?(?<!\\<\/div>|.{6}\\)(?:\1|<div>)/gi,
        "literal",
        splitAcrossLines,
        "$", "$");  // mark hidden text with dollar signs at either end

    // color-code numbers
    styler.updateMatchedText(/-?\.?\d[a-z\d\-\.]*/gi, "literal");
}

// -------------------------------------

// convert list of identifiers into a regular expression
function regexFromList(list) {

    // must work for preprocessor directives
    return new RegExp("(?<![#\\w])(?:" + list.join("|") + ")\\b", "g");
}

function stylePreprocessorDirectives(styler) {

    // color-code most preprocessor directives
    styler.updateMatchedText(
        regexFromList(preprocessor),  // build regex from list
        "preprocessor");

    // color-code "#define" directives
    const groups = [null, [] ];  // only return 2nd capture group
    styler.findCaptureGroups(
        /(#define)\s+([A-Za-z_]\w*)/g,
        ["preprocessor"],  // style for 1st capture group
        groups);

    // color-code any macros retrieved in previous step
    if (groups[1].length > 0) {

        styler.updateMatchedText(
            regexFromList(groups[1]),  // build regex from list
            "macro",
            null,       // macros are all single tokens
            "$", "$");  // mark hidden text with dollar signs
    }
}

// -------------------------------------

// find closing match for given pair of symbols
function findClosingDelimiter(text, opensAt, opener, closer) {

    let closesAt = opensAt;
    do {

        // find possible match
        closesAt = text.indexOf(closer, closesAt + closer.length);
        if (closesAt < 0) {
            closesAt = text.length;
        }

        // find next opener
        opensAt = text.indexOf(opener, opensAt + opener.length);
        if (opensAt < 0) {
            opensAt = text.length;
        }

    // keep looking until next opener is after current closer
    // don't use <= because potentially causes infinite loop
    } while (opensAt < closesAt);

    return closesAt;
}

function styleLocalVariables(styler, parameters) {

    // check for function body
    const text = styler.edited.substring(parameters.stop);
    if (text.search(/\)(?:\s|<\/?div>|<br>)*\{/i) !== 0) {
        return;
    }

    // scope down to just parameter list
    styler.setScope(parameters.start, parameters.stop + 1);

    // find parameter names
    const groups = [ [] ];  // return 1st (and only) capture group
    styler.findCaptureGroups(
        /\b(\w+)(?:\s|<\/?div>|<br>)*(?:,|\))/gi,
        ["variable"],  // style for names in parameter list
        groups);

    // change scope to function body
    const opensAt  = text.indexOf("{");
    const closesAt = findClosingDelimiter(text, opensAt, "{", "}");
    styler.setScope(opensAt + 1, closesAt);

    // color-code parameter names
    if (groups[0].length > 0) {

        styler.updateMatchedText(
            regexFromList(groups[0]),
            "variable");
    }

    styler.clearScope();
}

function styleFunctions(styler) {

    // find functions and their parameter lists
    const groups = [ [], [] ];           // return both capture groups
    const styles = [ "", "parameters"];  // temp style for 2nd group
    styler.findCaptureGroups(
        /([a-z_]\w*)(?:\s|<\/?div>|<br>)*\((.*?)\)/gi,
        styles,
        groups);

    // color-code function names
    if (groups[0].length > 0) {

        styler.updateMatchedText(
            regexFromList(groups[0]),
            "function");
    }

    // extract parameter list Styling objects
    const parameters = styler.styling
        .filter(function(s) { return s.style === styles[1]; });

    // remove temporary style
    styler.removeStyling(styles[1]);

    // find and color-code variable names within each function
    for (let i = 0; i < parameters.length; i++) {
        styleLocalVariables(styler, parameters[i]);
    }
}

// -------------------------------------

// saves and restores text caret after updating inner HTML
// should probably be rewritten to count <div> tags or something
function preserveCaret(element, html) {

    const selection = window.getSelection();
    if (!selection || selection.rangeCount < 1) {
        element.innerHTML = html;
        return;
    }

    const range = selection.getRangeAt(0).cloneRange();
    range.setStart(element, 0);
    let caret = range.toString().length;

    element.innerHTML = html;

    const tree = document.createTreeWalker(element, NodeFilter.SHOW_TEXT);
    while (tree.nextNode() && caret > tree.currentNode.length) {
        caret -= tree.currentNode.length;
    }
    caret = Math.min(caret, tree.currentNode.length);

    range.setStart(tree.currentNode, caret);
    range.collapse(true);
    selection.removeAllRanges();
    selection.addRange(range);
}

// apply styling step-by-step and display for user
function styleEditBox() {

    // matches HTML-encoded line breaks
    const splitAcrossLines = /<\/?div>|<br>/i;

    const editBox = document.getElementById("editBox");
    const html    = unstyledFromStyled(editBox.innerHTML);
    const styler  = new StyleBuilder(html);

    styleCommentsAndLiterals(styler, splitAcrossLines);
    stylePreprocessorDirectives(styler);

    // color-code most keywords
    styler.updateMatchedText(
        regexFromList(keyword),
        "keyword",
        null,       // keywords are all single tokens
        "$", "$");  // mark hidden text with dollar signs at either end

    styleFunctions(styler);

    // apply styling and update edit box
    preserveCaret(editBox, styler.buildStyledHTML());
}

// -----------------------------------------------------------------------------

let hasChanges = false;  // edit box dirty flag
let stylingTimer;        // timer ID for debouncing

// -------------------------------------

// EVENT LISTENER - attached by initialize()
// after no input for 2 seconds, update styles used in edit box
function debounceStyling() {

    hasChanges = true;

    // restart timer
    clearTimeout(stylingTimer);  // silently errors on invalid timer ID
    stylingTimer = setTimeout(styleEditBox, 2000);
}

function confirmDropChanges() {

    return !hasChanges ||
           confirm("You will lose any unsaved changes.");
}

// reset edit box to starting conditions
function clearEditBox() {

    if (!confirmDropChanges()) {
        return;
    }

    document.getElementById("editBox").innerHTML = "";
    document.getElementById("fileName").value    = "temp.txt";
    hasChanges                                   = false;
}

// -------------------------------------

// trigger hidden file picker control
function pickFile() {

    if (!confirmDropChanges()) {
        return;
    }

    document.getElementById("filePicker").click();
}

// EVENT LISTENER - attached by readFile()
// convert file to HTML, load, and style
function loadFile(text) {

    document.getElementById("editBox").innerHTML = htmlFromText(text);

    styleEditBox();
    hasChanges = false;
}

// EVENT LISTENER - attached by initialize()
// read selected file and load into edit box
function readFile() {

    if (this.files.length < 1) {
        return;  // file picker cancelled!
    }

    let fileName = this.files[0].name;
    if (fileName.indexOf(".") < 0) {
        fileName += ".";
    }
    document.getElementById("fileName").value = fileName;

    const reader = new FileReader();
    reader.addEventListener("load", function () {
        loadFile(reader.result);
    });

    reader.readAsText(this.files[0]);
    this.value = "";  // clear file picker
}

// -------------------------------------

// package up file and simulate clicking download link
function dispatchFile(name, type, content) {

    const file = new Blob([content], { type: type });
    const url  = URL.createObjectURL(file);

    const link    = document.createElement("a");
    link.href     = url;
    link.download = name;  // set file name

    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    URL.revokeObjectURL(url);  // clean up temp URL
}

// determine file name and official "type" of download
function downloadFile() {

    let type = "text/plain";
    let name = document.getElementById("fileName").value;
    if (name.indexOf(".") < 0) {
        name += ".txt";  // append default extension
    }

    else if (name.at(-1) == ".") {
        name = name.substring(0, name.length - 1);  // chop off period
        type = "application/octet-stream";  // prevent default extension
    }

    const editBox = document.getElementById("editBox");
    const content = textFromHTML(editBox.innerHTML);

    dispatchFile(name, type, content);  // package file and dispatch
    hasChanges = false;
}

// -------------------------------------

// attach event listeners and prep edit box for user
function initialize() {

    document
        .getElementById("filePicker")
        .addEventListener("change", readFile);

    document
        .getElementById("editBox")
        .addEventListener("input", debounceStyling);

    clearEditBox();
}

// -----------------------------------------------------------------------------
    </script>

</head>
<body onload="initialize()">

    <div class="viewPort">
        <div class="toolBar">

            <input type="button"
                   value="New File"
                   onclick="clearEditBox()">

            <!-- invisible and hidden behind other controls -->
            <input type="file"
                   id="filePicker"
                   accept="text/plain">

            <!-- triggers file picker above -->
            <input type="button"
                   value="Open File"
                   onclick="pickFile()">

            <input type="button"
                   value="Save to Downloads"
                   onclick="downloadFile()">

            <label for="fileName">Current File:</label>
            <input type="text"
                   id="fileName">

        </div>
        <div id="editBox"
             contenteditable="true"
             spellcheck="false"></div>
    </div>

</body>
</html>
